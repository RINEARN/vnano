/*
 * Copyright(C) 2018-2022 RINEARN
 * This software is released under the MIT License.
 */

package org.vcssl.nano.main;

import java.util.List;
import java.util.Locale;
import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import org.vcssl.connect.ConnectorException;
import org.vcssl.connect.ConnectorImplementationContainer;
import org.vcssl.connect.ConnectorImplementationLoader;
import org.vcssl.connect.ConnectorPermissionName;
import org.vcssl.connect.ConnectorPermissionValue;
import org.vcssl.nano.VnanoEngine;
import org.vcssl.nano.VnanoException;
import org.vcssl.nano.combinedtest.CombinedTestException;
import org.vcssl.nano.combinedtest.CombinedTestExecutor;
import org.vcssl.nano.interconnect.Interconnect;
import org.vcssl.nano.interconnect.PluginLoader;
import org.vcssl.nano.interconnect.ScriptLoader;
import org.vcssl.nano.spec.SpecialBindingKey;
import org.vcssl.nano.spec.EngineInformation;
import org.vcssl.nano.spec.OptionKey;
import org.vcssl.nano.spec.OptionValue;
import org.vcssl.nano.vm.VirtualMachine;


/**
 * The class processing the command line mode.
 */
public final class VnanoCommandLineApplication {

	/**
	 * Prints the content of the --help option.
	 */
	public void help() {
		if (   ( this.locale.getLanguage()!=null && this.locale.getLanguage().toLowerCase().equals("ja") )
			   || ( this.locale.getCountry()!=null && this.locale.getCountry().toLowerCase().equals("jp") )   ) {

			this.helpInJapanese();
		} else {
			this.helpInEnglish();
		}
	}

	/**
	 * Prints the content of the --help option, in English.
	 */
	public void helpInEnglish() {
		System.out.print("Vnano " + EngineInformation.ENGINE_VERSION);
		System.out.println("  (Command-Line Mode)");

		System.out.println("");
		System.out.println("[ Usage ]");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar fileName");
		System.out.println("");
		System.out.println("        or,");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar fileName --option1 value1 --option2 value2 ...");
		System.out.println("");
		System.out.println("[ Options ]");
		System.out.println("");

		System.out.println("  --help");
		System.out.println("");
		System.out.println("    Show this help messages.");
		System.out.println("");
		System.out.println("");

		System.out.println("  --file <filePath>");
		System.out.println("");
		System.out.println("    Load the script code (.vnano) or the VRIL code (.vril) from the file.");
		System.out.println("    This is the default option for 1-argument.");
		System.out.println("    You can skip to describe this option name for simplicity of the commands.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar --file Example.vnano");
		System.out.println("      java -jar Vnano.jar --file Example.vril");
		System.out.println("      java -jar Vnano.jar Example.vnano");
		System.out.println("      java -jar Vnano.jar Example.vril");
		System.out.println("");
		System.out.println("");

		System.out.println("  --encoding <encodingName>");
		System.out.println("");
		System.out.println("      Specify the text-encoding of the script file.");
		System.out.println("      The default text-encoding on this mode is UTF-8.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --encoding UTF-8");
		System.out.println("      java -jar Vnano.jar Example.vnano --encoding Shift_JIS");
		System.out.println("");
		System.out.println("");

		System.out.println("  --locale <localeCode>");
		System.out.println("");
		System.out.println("      Specify the locale to determine the language of error messages.");
		System.out.println("      The default locale depends on your environment.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --locale En-US");
		System.out.println("      java -jar Vnano.jar Example.vnano --locale Ja-JP");
		System.out.println("");
		System.out.println("");

		System.out.println("  --dump <dumpTarget>");
		System.out.println("");
		System.out.println("      Dump the intermediate information to the standard output, for debugging.");
		System.out.println("      You can choose and specify the <dumpTarget> from the following list:");
		System.out.println("");
		System.out.println("        inputtedCode     : Content of the script code loaded from the file.");
		System.out.println("        preprocessedCode : Comment-removed script code generated by the preprocessor.");
		System.out.println("        token            : Tokens generated by the lexical analyzer.");
		System.out.println("        parsedAst        : Abstract Syntax Tree (AST) generated by the parser.");
		System.out.println("        analyzedAst      : Information-appended AST generated by the semantic analyzer.");
		System.out.println("        assemblyCode     : Virtual assembly code written in the VRIL, generated by the code generator.");
		System.out.println("        objectCode       : Virtual object code running on the VM, generated by the assembler.");
		System.out.println("        acceleratorCode  : Optimized instruction code running on the VM when the accelerator is enabled.");
		System.out.println("        acceleratorState : Internal state of the accelerator.");
		System.out.println("        all (default)    : All of the above dump targets.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --dump");
		System.out.println("      java -jar Vnano.jar Example.vnano --dump all");
		System.out.println("      java -jar Vnano.jar Example.vnano --dump assemblyCode");
		System.out.println("");
		System.out.println("");

		System.out.println("  --run <runOrNot>");
		System.out.println("");
		System.out.println("      Specify whether you want to run the code loaded from the file or not.");
		System.out.println("      This option is specified by default, and the default value is true.");
		System.out.println("      You can choose and specify the value of <runOrNot> from the followings:");
		System.out.println("");
		System.out.println("        true (default) : Run the code.");
		System.out.println("        false          : Don't run the code.");
		System.out.println("");
		System.out.println("      This option is useful for the combination usage with the --dump option.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --run false");
		System.out.println("      java -jar Vnano.jar Example.vnano --run false --dump assemblyCode");
		System.out.println("      java -jar Vnano.jar Example.vnano --run false --dump assemblyCode > debug.txt");
		System.out.println("");
		System.out.println("");

		System.out.println("  --accelerator <enableOrDisable>");
		System.out.println("");
		System.out.println("      Specify whether you want to enable the accelerator.");
		System.out.println("      This option is specified by default, and the default value is true.");
		System.out.println("      You can choose and specify the value of <enableOrDisable> from the followings:");
		System.out.println("");
		System.out.println("        true (default) : Enable the accelerator.");
		System.out.println("        false          : Disable the accelerator.");
		System.out.println("");
		System.out.println("      The accelerator enables high-speed processing, but it has very complex implementation.");
		System.out.println("      When you feel that there is some bug for interpretation of a script,");
		System.out.println("      sometimes you may avoid it by disabling the accelerator.");
		System.out.println("      Please note that, if you disable it, significant slow-down occurs on processing.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --accelerator true");
		System.out.println("      java -jar Vnano.jar Example.vnano --accelerator false");
		System.out.println("");
		System.out.println("");

		System.out.println("  --optLevel <optimizationLevel>");
		System.out.println("");
		System.out.println("      Specify the value of the optimization level.");
		System.out.println("      This option is specified by default, and the default value is "
										+ OptionValue.ACCELERATOR_OPTIMIZATION_LEVEL_DEFAULT + ".");
		System.out.println("      The value of <optimizationLevel> is an integer grater than or equals to 0,");
		System.out.println("      and the maximum level currently supported is "
										+ OptionValue.ACCELERATOR_OPTIMIZATION_LEVEL_MAX + ".");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --optLevel 0");
		System.out.println("      java -jar Vnano.jar Example.vnano --optLevel 3");
		System.out.println("");
		System.out.println("");

		System.out.println("  --terminator <enableOrDisable>");
		System.out.println("");
		System.out.println("      Specify whether you want to enable the terminator.");
		System.out.println("      This option is specified by default, and the default value is false.");
		System.out.println("      You can choose and specify the value of <enableOrDisable> from the followings:");
		System.out.println("");
		System.out.println("        true            : Enable the terminator.");
		System.out.println("        false (default) : Disable the terminator.");
		System.out.println("");
		System.out.println("      Note that, the terminator is the feature for terminating scripts from application-side equipped");
		System.out.println("      with the Vnano Engine, so there is no situation to use the terminator on the command-line mode.");
		System.out.println("      However, this option is useful for measuring (a little) slow-down in processing speed,");
		System.out.println("      occurred when the terminator is enabled.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --terminator true");
		System.out.println("      java -jar Vnano.jar Example.vnano --terminator false");
		System.out.println("");
		System.out.println("");

		System.out.println("  --perf <perfTarget>");
		System.out.println("");
		System.out.println("      Enable the performance monitor.");
		System.out.println("      You can choose and specify the <perfTarget> from the following list:");
		System.out.println("");
		System.out.println("        speed            : VM drive speed (Number of executed instructions per second).");
		System.out.println("        ram              : Memory usage.");
		System.out.println("        instructionFreq  : Frequencies of that each instruction is being executed at periodic sampling moments.");
		System.out.println("        all (default)    : All of the above performance monitoring targets.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --perf");
		System.out.println("      java -jar Vnano.jar Example.vnano --perf all");
		System.out.println("      java -jar Vnano.jar Example.vnano --perf speed");
		System.out.println("");
		System.out.println("");

		System.out.println("  --plugin <pluginPath>");
		System.out.println("");
		System.out.println("      Specify the class path of the plug-in to be connected.");
		System.out.println("      Multiple paths can be specified by separating with \":\" or \";\"");
		System.out.println("      (depends on the environment).");
		System.out.println("      If the root hierarchy of the class path of the plug-in is not \"" + DEFAULT_PLUGIN_DIR + "\" directory,");
		System.out.println("      specify that directory by --pluginDir option BEFORE this option.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin ExamplePlugin");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin examplepackage.ExamplePlugin");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin \"Plugin1;Plugin2;Plugin3\"");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin \"Plugin1:Plugin2:Plugin3\"");
		System.out.println("      java -jar Vnano.jar Example.vnano --pluginDir \"./exampleDir/\" --plugin \"ExamplePlugin\"");
		System.out.println("");
		System.out.println("");

		System.out.println("  --pluginDir <pluginDirectoryPath>");
		System.out.println("");
		System.out.println("      Specify the file path of the directory at the root hierarchy of class paths of plug-ins.");
		System.out.println("      Multiple file paths can be specified by separating with \":\" or \";\"");
		System.out.println("      (depends on the environment).");
		System.out.println("      The default value is \"" + DEFAULT_PLUGIN_DIR + "\".");
		System.out.println("");
		System.out.println("");

		System.out.println("  --pluginList <pluginListFilePath>");
		System.out.println("");
		System.out.println("      Specify the file path of the plugin-list file in which file paths of plug-ins ");
		System.out.println("      to be loaded are described.");
		System.out.println("      The default value is \""+ DEFAULT_PLUGIN_LIST_FILE_PATH + "\".");
		System.out.println("");
		System.out.println("");

		System.out.println("  --libList <libraryListFilePath>");
		System.out.println("");
		System.out.println("      Specify the file path of the library-list file in which file paths of library-scripts ");
		System.out.println("      to be loaded are described.");
		System.out.println("      The default value is \""+ DEFAULT_LIBRARY_LIST_FILE_PATH + "\".");
		System.out.println("");
		System.out.println("");

		System.out.println("  --permission <permissionSettingsName>");
		System.out.println("");
		System.out.println("      Specify the name of the permission settings.");
		System.out.println("      This option is specified by default, and the default value is \"" + PERMISSION_VALUE_DENY_ALL + "\"");
		System.out.println("      You can choose and specify the value of <permissionSettingsName> from the followings:");
		System.out.println("");
		System.out.println("          denyAll   : Denies all permission requests.");
		System.out.println("          allowAll  : Allows all permission requests.");
		System.out.println("          askAll    : Asks users whether allow or deny each permission request, for all permission items.");
		System.out.println("");
		System.out.println("          balanced  : The settings considering the balance between usability and protectivity, as follows:");
		System.out.println("");
		System.out.println("                        * DEFAULT:          ASK");
		System.out.println("                        * FILE_CREATE:      ALLOW");
		System.out.println("                        * FILE_WRITE:       ALLOW");
		System.out.println("                      ( * FILE_OVERWRITE:   ASK   )");
		System.out.println("                        * FILE_READ:        ALLOW");
		System.out.println("                        * DIRECTORY_CREATE: ALLOW");
		System.out.println("                        * DIRECTORY_LIST:   ALLOW");
		System.out.println("                        * PROGRAM_EXIT:     ALLOW");
		System.out.println("                        * PROGRAM_RESET:    ALLOW");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --permission denyAll");
		System.out.println("      java -jar Vnano.jar Example.vnano --permission askAll");
		System.out.println("      java -jar Vnano.jar Example.vnano --permission balanced");
		System.out.println("");
		System.out.println("");

		System.out.println("  --test");
		System.out.println("");
		System.out.println("      Execute combined tests of the script engine of the Vnano.");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar --test");
		System.out.println("");
		System.out.println("");

		System.out.println("[ Default Supported Functions ]");
		System.out.println("");
		System.out.println("    For development and debugging, following functions are available");
		System.out.println("    in the script code running on this mode:");
		System.out.println("");
		System.out.println("      void output(int)");
		System.out.println("      void output(long)");
		System.out.println("      void output(float)");
		System.out.println("      void output(double)");
		System.out.println("      void output(bool)");
		System.out.println("      void output(string)");
		System.out.println("      int  time()");
		System.out.println("");
		System.out.println("    Please note that these functions are supported by default ONLY ON THIS MODE.");
		System.out.println("    No default functions are supported when the script engine is embedded in ");
		System.out.println("    other applications, so it is necessary to implement and connect ");
		System.out.println("    functions(methods) you want to use in the other application to the script engine.");
		System.out.println("");
		System.out.println("    When you want to use the above functions, and other fundamental functions,");
		System.out.println("    intdocude Vnano Standard Plug-ins, and connect them to the engine.");
		System.out.println("    For details, see documents of the Vnano Engine.");
		System.out.println("");
	}

	/**
	 * Prints the content of the --help option, in Japanese.
	 */
	public void helpInJapanese() {
		System.out.print("Vnano " + EngineInformation.ENGINE_VERSION);
		System.out.println(" （コマンドラインモード）");

		System.out.println("");
		System.out.println("[ 使用方法 ]");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar スクリプト名");
		System.out.println("");
		System.out.println("        または");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar スクリプト名 --オプション名1 オプション値1 --オプション名2 オプション値2 ...");
		System.out.println("");
		System.out.println("[ オプション ]");
		System.out.println("");

		System.out.println("  --help");
		System.out.println("");
		System.out.println("    現在表示されている、メッセージを表示します。");
		System.out.println("");
		System.out.println("");

		System.out.println("  --file ファイルパス");
		System.out.println("");
		System.out.println("    ファイルから、実行するスクリプトコード (.vnano) または VRIL コード (.vril) を読み込みます。");
		System.out.println("    このオプションの --file の部分はは省略可能です。");
		System.out.println("    また、コマンドライン引数が一個だけの場合、このオプションの値と解釈されます。");
		System.out.println("");
		System.out.println("    使用例：");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar --file Example.vnano");
		System.out.println("      java -jar Vnano.jar --file Example.vril");
		System.out.println("      java -jar Vnano.jar Example.vnano");
		System.out.println("      java -jar Vnano.jar Example.vril");
		System.out.println("");
		System.out.println("");

		System.out.println("  --encoding 文字コード名");
		System.out.println("");
		System.out.println("      スクリプトファイルの文字コードを指定します。");
		System.out.println("      コマンドラインモードでのデフォルトの文字コードは「 UTF-8 」です。");
		System.out.println("");
		System.out.println("    使用例：");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --encoding UTF-8");
		System.out.println("      java -jar Vnano.jar Example.vnano --encoding Shift_JIS");
		System.out.println("");
		System.out.println("");

		System.out.println("  --locale ロケール名");
		System.out.println("");
		System.out.println("      エラーメッセージ等の言語を決めるための、ロケール（≒地域/言語の区分コード）を指定します。");
		System.out.println("      デフォルトのロケールは、実行されている環境に合わせて自動設定されます。");
		System.out.println("");
		System.out.println("    e.g.");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --locale En-US");
		System.out.println("      java -jar Vnano.jar Example.vnano --locale Ja-JP");
		System.out.println("");
		System.out.println("");

		System.out.println("  --dump ダンプ対象");
		System.out.println("");
		System.out.println("      エンジン内部での、スクリプト処理に関する中間表現を、標準出力にダンプします（デバッグ用）。");
		System.out.println("      ダンプ対象の値は、以下の一覧から指定できます：");
		System.out.println("");
		System.out.println("        inputtedCode     : ファイルから読み込まれたままの内容");
		System.out.println("        preprocessedCode : プリプロセッサで、コメント等が除去されたコード");
		System.out.println("        token            : コードから、字句解析器によって分割されたトークン列");
		System.out.println("        parsedAst        : 構文解析器で生成された直後の抽象構文木（AST）");
		System.out.println("        analyzedAst      : 意味解析器によって、型情報などが補完された抽象構文木（AST）");
		System.out.println("        assemblyCode     : コード生成器で生成された、VRILで記述された仮想的なアセンブリコード");
		System.out.println("        objectCode       : アセンブラで生成された、仮想マシン（VM）上で実行可能なオブジェクトコード");
		System.out.println("        acceleratorCode  : 最適化された命令列（アクセラレーター有効時のみ使用可能）");
		System.out.println("        acceleratorState : アクセラレーターの内部状態（アクセラレーター有効時のみ使用可能）");
		System.out.println("        all (デフォルト) : 上記の全て");
		System.out.println("");
		System.out.println("    使用例：");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --dump");
		System.out.println("      java -jar Vnano.jar Example.vnano --dump all");
		System.out.println("      java -jar Vnano.jar Example.vnano --dump assemblyCode");
		System.out.println("");
		System.out.println("");

		System.out.println("  --run 実行するかどうか");
		System.out.println("");
		System.out.println("      読み込んだスクリプトを、実行するかどうかを指定します。");
		System.out.println("      このオプションは、デフォルトは true（実行する）に設定されています。");
		System.out.println("      以下のように、true か false の値を指定します：");
		System.out.println("");
		System.out.println("        true (デフォルト) : スクリプトを実行する");
		System.out.println("        false             : スクリプトを実行しない");
		System.out.println("");
		System.out.println("      このオプションは、例えば --dump オプションで構文解析処理のデバッグなどを行っていて、");
		System.out.println("      スクリプトの実行はさせたくない場合などに有用です。");
		System.out.println("");
		System.out.println("    使用例");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --run false");
		System.out.println("      java -jar Vnano.jar Example.vnano --run false --dump assemblyCode");
		System.out.println("      java -jar Vnano.jar Example.vnano --run false --dump assemblyCode > debug.txt");
		System.out.println("");
		System.out.println("");

		System.out.println("  --accelerator 有効化するかどうか");
		System.out.println("");
		System.out.println("      仮想マシン（VM）の高速版実装である、アクセラレーターを有効化するかどうかを指定します。");
		System.out.println("      このオプションは、デフォルトは true（有効化する）に設定されています。");
		System.out.println("      以下のように、true か false の値を指定します：");
		System.out.println("");
		System.out.println("        true (デフォルト) : アクセラレータを有効化する");
		System.out.println("        false             : アクセラレータを無効化する");
		System.out.println("");
		System.out.println("      アクセラレーターは、処理速度が高い半面、実装も非常に複雑です。");
		System.out.println("      スクリプトの解釈が何かおかしいと感じた際などに、無効化すると回避できるかもしれません。");
		System.out.println("      ただし、無効化すると処理速度が大幅に（文字通り桁違いに）低下します。");
		System.out.println("");
		System.out.println("    使用例");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --accelerator true");
		System.out.println("      java -jar Vnano.jar Example.vnano --accelerator false");
		System.out.println("");
		System.out.println("");

		System.out.println("  --optLevel 最適化レベル");
		System.out.println("");
		System.out.println("      最適化レベルを、0 から " + OptionValue.ACCELERATOR_OPTIMIZATION_LEVEL_MAX + " の範囲で指定します。");
		System.out.println("      デフォルトでは、最適化レベルは "
										+ OptionValue.ACCELERATOR_OPTIMIZATION_LEVEL_DEFAULT + "に設定されています。");
		System.out.println("");
		System.out.println("    使用例");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --optLevel 0");
		System.out.println("      java -jar Vnano.jar Example.vnano --optLevel 3");
		System.out.println("");
		System.out.println("");

		System.out.println("  --terminator 有効化するかどうか");
		System.out.println("");
		System.out.println("      スクリプトを途中終了させるための機能である、ターミネーターを有効化するかどうかを指定します。");
		System.out.println("      このオプションは、デフォルトで false（無効化する）に設定されています。");
		System.out.println("      以下のように、true か false の値を指定します：");
		System.out.println("");
		System.out.println("        true               : ターミネーターを有効化する");
		System.out.println("        false (デフォルト) : ターミネーターを無効化する");
		System.out.println("");
		System.out.println("      なお、ターミネーターは、アプリケーションにスクリプトエンジンを組み込んだ際のための機能であり、");
		System.out.println("      コマンドラインモードでは作動させる機会はありません（そのためデフォルトで false になっています）。");
		System.out.println("      一方で、有効化すると若干の速度低下が生じるため、このオプションはその度合の把握のために用います。");
		System.out.println("");
		System.out.println("    使用例：");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --terminator true");
		System.out.println("      java -jar Vnano.jar Example.vnano --terminator false");
		System.out.println("");
		System.out.println("");

		System.out.println("  --perf 計測対象");
		System.out.println("");
		System.out.println("      性能計測を有効化するかどうかを指定します。");
		System.out.println("      計測対象の値は、以下の一覧から指定できます：");
		System.out.println("");
		System.out.println("        speed            : 仮想（VM）マシンの動作速度（秒間あたり命令実行数）");
		System.out.println("        ram              : メモリー使用量");
		System.out.println("        instructionFreq  : 各命令種類ごとの実行頻度（サンプリングにより計測）");
		System.out.println("        all (default)    : 上記の全て");
		System.out.println("");
		System.out.println("    使用例");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --perf");
		System.out.println("      java -jar Vnano.jar Example.vnano --perf all");
		System.out.println("      java -jar Vnano.jar Example.vnano --perf speed");
		System.out.println("");
		System.out.println("");

		System.out.println("  --plugin プラグインのパス");
		System.out.println("");
		System.out.println("      接続するプラグインのクラスパスを指定します。");
		System.out.println("      パスは、「:」または「;」区切り（環境依存）で複数指定できます。");
		System.out.println("      プラグインのクラスパスのルートディレクトリが「 " + DEFAULT_PLUGIN_DIR + " 」ディレクトリではない場合、");
		System.out.println("      --pluginDir をこのオプションよりも前に付けて、そのディレクトリを指定します。");
		System.out.println("");
		System.out.println("    使用例：");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin ExamplePlugin");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin examplepackage.ExamplePlugin");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin \"Plugin1;Plugin2;Plugin3\"");
		System.out.println("      java -jar Vnano.jar Example.vnano --plugin \"Plugin1:Plugin2:Plugin3\"");
		System.out.println("      java -jar Vnano.jar Example.vnano --pluginDir \"./exampleDir/\" --plugin \"ExamplePlugin\"");
		System.out.println("");
		System.out.println("");

		System.out.println("  --pluginDir プラグインのクラスパスにおけるルート階層ディレクトリのパス");
		System.out.println("");
		System.out.println("      プラグインのクラスパスにおいて、ルート階層に位置するディレクトリのファイルパスを指定します。");
		System.out.println("      ファイルパスは、「:」または「;」区切り（環境依存）で複数指定できます。");
		System.out.println("      このオプションは、デフォルトで「 " + DEFAULT_PLUGIN_DIR + " 」に設定されています。");
		System.out.println("");
		System.out.println("");

		System.out.println("  --pluginList プラグインリストファイルのパス");
		System.out.println("");
		System.out.println("      読み込み対処のプラグインが列挙されている、「プラグイン リスト ファイル」のファイルパスを指定します。");
		System.out.println("      このオプションはデフォルトで「 "+ DEFAULT_PLUGIN_LIST_FILE_PATH + " 」に設定されています。");
		System.out.println("");
		System.out.println("");

		System.out.println("  --libList ライブラリリストファイルのパス");
		System.out.println("");
		System.out.println("      読み込み対処のライブラリが列挙されている、「ライブラリ リスト ファイル」のファイルパスを指定します。");
		System.out.println("      このオプションはデフォルトで「 "+ DEFAULT_LIBRARY_LIST_FILE_PATH + " 」に設定されています。");
		System.out.println("");
		System.out.println("");

		System.out.println("  --permission パーミッション設定名");
		System.out.println("");
		System.out.println("      パーミッション設定を選択指定します。");
		System.out.println("      このオプションはデフォルトで「 " + PERMISSION_VALUE_DENY_ALL + " 」に設定されています。");
		System.out.println("      下記の一覧から選んで指定できます：");
		System.out.println("");
		System.out.println("          denyAll   : 全てのパーミッション要求を拒否します。");
		System.out.println("          allowAll  : 全てのパーミッション要求を許可します。");
		System.out.println("          askAll    : 各パーミッションのリクエスト時に、ユーザーに尋ねて決定します。");
		System.out.println("");
		System.out.println("          balanced  : 一般的な用途を想定し、利便性と保護のバランスを考慮した設定（下記）を使用します：");
		System.out.println("");
		System.out.println("                        * DEFAULT:          ASK");
		System.out.println("                        * FILE_CREATE:      ALLOW");
		System.out.println("                        * FILE_WRITE:       ALLOW");
		System.out.println("                      ( * FILE_OVERWRITE:   ASK   )");
		System.out.println("                        * FILE_READ:        ALLOW");
		System.out.println("                        * DIRECTORY_CREATE: ALLOW");
		System.out.println("                        * DIRECTORY_LIST:   ALLOW");
		System.out.println("                        * PROGRAM_EXIT:     ALLOW");
		System.out.println("                        * PROGRAM_RESET:    ALLOW");
		System.out.println("");
		System.out.println("    使用例");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar Example.vnano --permission denyAll");
		System.out.println("      java -jar Vnano.jar Example.vnano --permission askAll");
		System.out.println("      java -jar Vnano.jar Example.vnano --permission balanced");
		System.out.println("");
		System.out.println("");

		System.out.println("  --test");
		System.out.println("");
		System.out.println("      Vnano のスクリプトエンジンの全体テストを実行します。");
		System.out.println("");
		System.out.println("    使用例");
		System.out.println("");
		System.out.println("      java -jar Vnano.jar --test");
		System.out.println("");
		System.out.println("");

		System.out.println("[ 標準で使用できる関数 ]");
		System.out.println("");
		System.out.println("    コマンドラインモードでは、開発やデバッグ時の利便性のため、以下の関数が標準で使用できます。");
		System.out.println("");
		System.out.println("      void output(int)");
		System.out.println("      void output(long)");
		System.out.println("      void output(float)");
		System.out.println("      void output(double)");
		System.out.println("      void output(bool)");
		System.out.println("      void output(string)");
		System.out.println("      int  time()");
		System.out.println("");
		System.out.println("    一方でこれらは、スクリプトエンジンをアプリケーションに組み込んだ際などには、");
		System.out.println("    標準では使えない事に留意が必要です。標準で使えるのは、あくまでもコマンドラインモードでのみです。");
		System.out.println("");
		System.out.println("    アプリケーションへの組み込み時に、上記の関数や、その他の基本的な関数を使用可能にするには、");
		System.out.println("    Vnano標準プラグインを導入し、読み込み設定を行ってください。");
		System.out.println("    詳細は　Vnano Engine のドキュメントをご参照ください。");
		System.out.println("");
	}


	/** The locale of command line messages (including error messages). */
	private Locale locale = Locale.getDefault();

	/** The default encoding (charset) of files (script files, library list files, and so on). */
	private static final String DEFAULT_ENCODING = "UTF-8";

	/** The file path of the library list file, to be loaded by default. */
	private static final String DEFAULT_LIBRARY_LIST_FILE_PATH = "lib/VnanoLibraryList.txt";

	/** The file path of the plugin list file, to be loaded by default. */
	private static final String DEFAULT_PLUGIN_LIST_FILE_PATH = "plugin/VnanoPluginList.txt";

	/** The default directory in which the library files should be located. */
	@SuppressWarnings("unused")
	private static final String DEFAULT_LIBRARY_DIR = "lib/";

	/** The default directory in which the plugin files should be located. */
	private static final String DEFAULT_PLUGIN_DIR = "plugin/";

	/** The extension of Vnano script files. */
	private static final String EXTENSION_VNANO = ".vnano";

	/** The extension of VRIL assembly files. */
	private static final String EXTENSION_VRIL = ".vril";


	// --------------------------------------------------------------------------------
	// Definitions of The Names of Command Line Options
	// --------------------------------------------------------------------------------

	/** The prefix of command line options. */
	private static final String COMMAND_OPTNAME_PREFIX = "--";

	/** The name of --file option. */
	private static final String COMMAND_OPTNAME_FILE = "file";

	/** The name of --help option. */
	private static final String COMMAND_OPTNAME_HELP = "help";

	/** The name of --dump option. */
	private static final String COMMAND_OPTNAME_DUMP = "dump";

	/** The name of --run option. */
	private static final String COMMAND_OPTNAME_RUN = "run";

	/** The name of --locale option. */
	private static final String COMMAND_OPTNAME_LOCALE = "locale";

	/** The name of --version option. */
	private static final String COMMAND_OPTNAME_VERSION = "version";

	/** The name of --accelerator option. */
	private static final String COMMAND_OPTNAME_ACCELERATOR = "accelerator";

	/** The name of --terminator option. */
	private static final String COMMAND_OPTNAME_TERMINATOR = "terminator";

	/** The name of --perf option. */
	private static final String COMMAND_OPTNAME_PERF = "perf";

	/** The name of --optLevel option. */
	private static final String COMMAND_OPTNAME_OPTLEVEL = "optLevel";

	/** The name of --encoding option. */
	private static final String COMMAND_OPTNAME_ENCODING = "encoding";

	/** The name of --pluginDir option. */
	private static final String COMMAND_OPTNAME_PLUGIN_DIR = "pluginDir";

	/** The name of --plugin option. */
	private static final String COMMAND_OPTNAME_PLUGIN = "plugin";

	/** The name of --pluginList option. */
	private static final String COMMAND_OPTNAME_PLUGIN_LIST = "pluginList";

	/** The name of --libList option. */
	private static final String COMMAND_OPTNAME_LIBRARY_LIST = "libList";

	/** The name of --permission option. */
	private static final String COMMAND_OPTNAME_PERMISSION = "permission";

	/** The name of --test option. */
	private static final String COMMAND_OPTNAME_TEST = "test";

	/** The name of the default option (--file). */
	private static final String COMMAND_OPTNAME_DEFAULT = COMMAND_OPTNAME_FILE;


	// --------------------------------------------------------------------------------
	// Definitions of The Values of the --dump Option (dump target)
	// --------------------------------------------------------------------------------

	/** Represents the "inputtedCode" dump target. */
	private static final String DUMP_TARGET_INPUTTED_CODE = "inputtedCode";

	/** Represents the "preprocessedCode" dump target. */
	private static final String DUMP_TARGET_PREPROCESSED_CODE = "preprocessedCode";

	/** Represents the "token" dump target. */
	private static final String DUMP_TARGET_TOKEN = "token";

	/** Represents the "parsedAst" dump target. */
	private static final String DUMP_TARGET_PARSED_AST = "parsedAst";

	/** Represents the "analyzedAst" dump target. */
	private static final String DUMP_TARGET_ANALYZED_AST = "analyzedAst";

	/** Represents the "assemblyCode" dump target. */
	private static final String DUMP_TARGET_ASSEMBLY_CODE = "assemblyCode";

	/** Represents the "objectCode" dump target. */
	private static final String DUMP_TARGET_OBJECT_CODE = "objectCode";

	/** Represents the "acceleratorCode" dump target. */
	private static final String DUMP_TARGET_ACCELERATOR_CODE = "acceleratorCode";

	/** Represents the "acceleratorState" dump target. */
	private static final String DUMP_TARGET_ACCELERATOR_STATE = "acceleratorState";

	/** Represents the "all" dump target. */
	private static final String DUMP_TARGET_ALL = "all";

	/** Represents the default dump target ("all"), referred when only "--dump" is specified with no value. */
	private static final String DUMP_TARGET_DEFAULT = DUMP_TARGET_ALL;

	/** The Map for converting a value of --dump option to the corresponding element of {@link org.vcssl.nano.spec.OptionValue OptionValue} enum. */
	private static final Map<String, String> DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP = new HashMap<String, String>();
	static {
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_INPUTTED_CODE, OptionValue.DUMPER_TARGET_INPUTTED_CODE);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_PREPROCESSED_CODE, OptionValue.DUMPER_TARGET_PREPROCESSED_CODE);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_TOKEN, OptionValue.DUMPER_TARGET_TOKEN);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_PARSED_AST, OptionValue.DUMPER_TARGET_PARSED_AST);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_ANALYZED_AST, OptionValue.DUMPER_TARGET_ANALYZED_AST);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_ASSEMBLY_CODE, OptionValue.DUMPER_TARGET_ASSEMBLY_CODE);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_OBJECT_CODE, OptionValue.DUMPER_TARGET_OBJECT_CODE);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_ACCELERATOR_CODE, OptionValue.DUMPER_TARGET_ACCELERATOR_CODE);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_ACCELERATOR_STATE, OptionValue.DUMPER_TARGET_ACCELERATOR_STATE);
		DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.put(DUMP_TARGET_ALL, OptionValue.DUMPER_TARGET_ALL);
	}


	// --------------------------------------------------------------------------------
	// Definitions of The Values of the --perf Option (perf target)
	// --------------------------------------------------------------------------------

	/** Represents the "speed" perf target. */
	private static final String PERF_TARGET_SPEED = "speed";

	/** Represents the "ram" perf target. */
	private static final String PERF_TARGET_RAM = "ram";

	/** Represents the "instructionFreq" perf target. */
	private static final String PERF_TARGET_INSTRUCTION_FREQ = "instructionFreq";

	/** Represents the "all" perf target. */
	private static final String PERF_TARGET_ALL = "all";

	/** Represents the default perf target ("all"), referred when only "--perf" is specified with no value. */
	private static final String PERF_TARGET_DEFAULT = PERF_TARGET_ALL;

	/** The Set of valid perf targets. */
	private static final Set<String> PERF_TARGET_SET = new HashSet<String>();
	static {
		PERF_TARGET_SET.add(PERF_TARGET_SPEED);
		PERF_TARGET_SET.add(PERF_TARGET_RAM);
		PERF_TARGET_SET.add(PERF_TARGET_INSTRUCTION_FREQ);
		PERF_TARGET_SET.add(PERF_TARGET_ALL);
	}

	/** The flag representing whether the --perf option is specified. */
	private boolean perfEnabled = false;

	/** Stores the specified value of the --perf option (perf target). */
	private String perfTarget = null;


	// --------------------------------------------------------------------------------
	// Definitions of The Values of the --permission Option (perf target)
	// --------------------------------------------------------------------------------

	/** Represents the permission settings denying all requests. */
	private static final String PERMISSION_VALUE_DENY_ALL = "denyAll";

	/** Represents the permission settings allowing all requests. */
	private static final String PERMISSION_VALUE_ALLOW_ALL = "allowAll";

	/** Represents the permission map asking users whether allows/deny a request, for all permission items. */
	private static final String PERMISSION_VALUE_ASK_ALL = "askAll";

	/** Represents the permission map considering the balance between usability and protectivity. */
	private static final String PERMISSION_VALUE_BALANCED = "balanced";

	/** Stores the map of the permission settings specified by --permission option. */
	private Map<String, String> permissionMap = PERMISSION_MAP_DENY_ALL;


	// --------------------------------------------------------------------------------
	// Definitions of Permission Maps
	// --------------------------------------------------------------------------------

	/** The permission map denying all requests. */
	@SuppressWarnings("serial")
	private static final Map<String, String> PERMISSION_MAP_DENY_ALL = new HashMap<String, String>() {{
		put(ConnectorPermissionName.DEFAULT, ConnectorPermissionValue.DENY);
	}};

	/** The permission map allowing all requests. */
	@SuppressWarnings("serial")
	private static final Map<String, String> PERMISSION_MAP_ALLOW_ALL = new HashMap<String, String>() {{
		put(ConnectorPermissionName.DEFAULT, ConnectorPermissionValue.ALLOW);
	}};

	/** The permission map asking users whether allows/deny a request, for all permission items. */
	@SuppressWarnings("serial")
	private static final Map<String, String> PERMISSION_MAP_ASK_ALL = new HashMap<String, String>() {{
		put(ConnectorPermissionName.DEFAULT, ConnectorPermissionValue.ASK);
	}};

	/** The permission map considering the balance between usability and protectivity. */
	@SuppressWarnings("serial")
	private static final Map<String, String> PERMISSION_MAP_BALANCED = new HashMap<String, String>() {{
		put(ConnectorPermissionName.DEFAULT, ConnectorPermissionValue.ASK);
		put(ConnectorPermissionName.PROGRAM_EXIT, ConnectorPermissionValue.ALLOW);
		put(ConnectorPermissionName.PROGRAM_RESET, ConnectorPermissionValue.ALLOW);
		put(ConnectorPermissionName.DIRECTORY_CREATE, ConnectorPermissionValue.ALLOW);
		put(ConnectorPermissionName.DIRECTORY_LIST, ConnectorPermissionValue.ALLOW);
		put(ConnectorPermissionName.FILE_CREATE, ConnectorPermissionValue.ALLOW);
		put(ConnectorPermissionName.FILE_WRITE, ConnectorPermissionValue.ALLOW);
		put(ConnectorPermissionName.FILE_READ, ConnectorPermissionValue.ALLOW);
	}};


	// --------------------------------------------------------------------------------
	// Others
	// --------------------------------------------------------------------------------

	/** The Map storing the specified (and default) option names and values, to be passed to the script engine.  */
	private Map<String, Object> engineOptionMap = new HashMap<String, Object>();

	/** Stores the specified values of --pluginDir option. */
	private List<String> optPluginDirList = new ArrayList<String>();

	/** Stores the specified values of --plugin option. */
	private List<Object> optPluginList = new ArrayList<Object>();

	/** Stores the specified value of --pluginList option. */
	private String optPluginListFilePath = null;

	/** Stores the specified value of --libList option. */
	private String optLibraryListFilePath = null;

	/** The flag representing whether the --test option is specified. */
	private boolean optCombinedTestRequired = false;


	/** The class providing functions available in scripts by default, on the command line mode. */
	public class ScriptIO {
		private long launchedTime = System.nanoTime() / 1000000l;

		public void output(long value) {
			System.out.println(value);
		}
		public void output(double value) {
			System.out.println(value);
		}
		public void output(boolean value) {
			System.out.println(value);
		}
		public void output(String value) {
			System.out.println(value);
		}
		public long time() {
			return System.nanoTime() / 1000000l - launchedTime;
		}
	}


	/**
	 * The entry-point of the process of the command line mode.
	 *
	 * @param args The specified command line arguments.
	 */
	public static void main(String[] args) {
		VnanoCommandLineApplication application = new VnanoCommandLineApplication();
		application.dispatch(args);
	}


	/**
	 * Dispatches/executes processes corresponding with each specified command line argument.
	 *
	 * @param args The specified command line arguments.
	 */
	public void dispatch(String[] args) {
		int argLength = args.length;

		// If no argument is specified, print the content of the --help option, and exit.
		if (argLength == 0) {
			this.help();
			return;
		}

		// If only the --help option is specified, print the content and exit.
		if (argLength == 1 && args[0].equals(COMMAND_OPTNAME_PREFIX + COMMAND_OPTNAME_HELP)) {
			this.help();
			return;
		}

		// Parse the specified arguments, and get the Map storing option names (as keys) and their values.
		Map<String, String> optionNameValueMap = this.parseArguments(args);

		// Dispatch/execute processes of all options.
		boolean optionProcessingSucceeded = true;
		Set<Map.Entry<String, String>> optionNameValueSet = optionNameValueMap.entrySet();
		for (Map.Entry<String, String> optionNameValuePair : optionNameValueSet) {
			if (!optionProcessingSucceeded) {
				break;
			}
			String optionName = optionNameValuePair.getKey();
			String optionValue = optionNameValuePair.getValue();
			optionProcessingSucceeded &= this.dispatchOptionProcessing(optionName, optionValue);
		}

		// Judge whether we should run a script.
		// (It does not required for some cases, e.g.: when only --help option is specified.)
		boolean scriptFileNecessary = this.isScriptFileNecessary(optionNameValueMap);

		// If the --test option is specified, run tests before running a script.
		if (this.optCombinedTestRequired) {
			optionProcessingSucceeded &= this.executeCombinedTest();
		}

		// If any option process has failed (including the above tests), exit with the status code 1.
		if (!optionProcessingSucceeded) {
			System.exit(1);
		}

		// If no script file is specified although it is required, error.
		// (It does not required for some cases.)
		if (scriptFileNecessary && !optionNameValueMap.containsKey(COMMAND_OPTNAME_FILE)) {
			System.err.println("No script file is specified.");
			System.exit(1);
		}

		// Get the file path of the specified script (as the value of the default option, or the value of --file option explicitly).
		String inputFilePath = optionNameValueMap.get(COMMAND_OPTNAME_FILE);

		// If the script file is specified, run it.
		if (inputFilePath != null) {

			// Determine the library list path by the following rule:
			// * If it is specified by the --libList option, use it.
			// * Otherwise, if the default library list file exists, use it.
			// * Otherwise, load no library.
			String libraryListPath = null;   // If this value is null, no library will be loaded.
			if (optLibraryListFilePath != null) {
				libraryListPath = optLibraryListFilePath;
			} else if (new File(DEFAULT_LIBRARY_LIST_FILE_PATH).exists()) {
				libraryListPath = DEFAULT_LIBRARY_LIST_FILE_PATH;
			}

			// Determine the plugin list path by the following rule:
			// * If it is specified by the --pluginList option, use it.
			// * Otherwise, if the default plugin list file exists, use it.
			// * Otherwise, load no plugins.
			String pluginListPath = null;   // If this value is null, no plugins will be loaded.
			if (optPluginListFilePath != null) {
				pluginListPath = optPluginListFilePath;
			} else if (new File(DEFAULT_PLUGIN_LIST_FILE_PATH).exists()) {
				pluginListPath = DEFAULT_PLUGIN_LIST_FILE_PATH;
			}

			// Get the default encoding for read text files (script, library list file, and plugin list file).
			// Note that, if there is an encoding-declaration line exist in a file, the declared encoding will be used for read the file.
			// The following encoding will be used for files in which no encoding-declaration line exits.
			String encoding = optionNameValueMap.containsKey(COMMAND_OPTNAME_ENCODING)
					? optionNameValueMap.get(COMMAND_OPTNAME_ENCODING) : DEFAULT_ENCODING;

			// Run the specified script.
			try {
				this.executeFile(inputFilePath, libraryListPath, pluginListPath, encoding);

			} catch (VnanoException e) {
				this.dumpException(e);
				if (!this.engineOptionMap.containsKey(OptionKey.DUMPER_ENABLED)) {
					System.err.println("For more debug information, re-execute the script with \"--dump\" option.");
				}
				System.exit(1);
			}
		}
	}


	/**
	 * Returns whether a script should be specified in the command line.
	 * (A script does not required for some cases, e.g.: when only --help option is specified.)
	 *
	 * @param optionNameValueMap The map storing the specified option names (as keys) and their values.
	 */
	private boolean isScriptFileNecessary(Map<String, String> optionNameValueMap) {
		if (optionNameValueMap.containsKey(COMMAND_OPTNAME_HELP) ) {
			return false;
		}
		if (optionNameValueMap.containsKey(COMMAND_OPTNAME_TEST) ) {
			return false;
		}
		if (optionNameValueMap.containsKey(COMMAND_OPTNAME_VERSION) ) {
			return false;
		}
		return true;
	}


	/**
	 * Dispatches/executes the process corresponding with the specified option.
	 *
	 * @param optionName The name of the option to be dispatched/executed.
	 * @param optionName The value of the option to be dispatched/executed.
	 * @return true if the process has completed successfully, or false it it has failed.
	 */
	public boolean dispatchOptionProcessing(String optionName, String optionValue) {
		if (optionName == null) {
			System.err.println("Fatal error: option name is null.");
			return false;
		}
		switch (optionName) {

			// --file option, or the default option:
			case COMMAND_OPTNAME_FILE : {
				// This option is detected and handled in dispatch() method, so do nothing here.
				return true;
			}

			// --help option:
			case COMMAND_OPTNAME_HELP : {
				this.help();
				return true;
			}

			// --run option:
			case COMMAND_OPTNAME_RUN : {
				this.engineOptionMap.put(OptionKey.RUNNING_ENABLED, Boolean.valueOf(optionValue));
				return true;
			}

			// --version option:
			case COMMAND_OPTNAME_VERSION : {
				System.out.println(EngineInformation.ENGINE_NAME + " " + EngineInformation.ENGINE_VERSION);
				return true;
			}

			// --accelerator option:
			case COMMAND_OPTNAME_ACCELERATOR : {
				if (optionValue.equals("true") || optionValue.equals("false")) {
					this.engineOptionMap.put(OptionKey.ACCELERATOR_ENABLED, Boolean.valueOf(optionValue));
				} else {
					System.err.println(
							"Invalid value for " + COMMAND_OPTNAME_PREFIX + COMMAND_OPTNAME_ACCELERATOR + "option: " + optionValue
					);
					return false;
				}
				return true;
			}

			// --optLevel option:
			case COMMAND_OPTNAME_OPTLEVEL : {
				int optimizationLevel = -1;
				try {
					optimizationLevel = Integer.parseInt(optionValue);
				} catch (NumberFormatException nfe) {
					System.err.println(
						"The value for " + COMMAND_OPTNAME_PREFIX + COMMAND_OPTNAME_ACCELERATOR + " should be an integer: " + optionValue
					);
					return false;
				}
				this.engineOptionMap.put(OptionKey.ACCELERATOR_OPTIMIZATION_LEVEL, Integer.valueOf(optimizationLevel));
				return true;
			}

			// --terminator option:
			case COMMAND_OPTNAME_TERMINATOR : {
				if (optionValue.equals("true") || optionValue.equals("false")) {
					this.engineOptionMap.put(OptionKey.TERMINATOR_ENABLED, Boolean.valueOf(optionValue));
				} else {
					System.err.println(
							"Invalid value for " + COMMAND_OPTNAME_PREFIX + COMMAND_OPTNAME_TERMINATOR + "option: " + optionValue
					);
					return false;
				}
				return true;
			}

			// --locale option:
			case COMMAND_OPTNAME_LOCALE : {

				// Note: The Constructors of the Locale class are deprecated,
				//       but the alternative method "Locale.toLocale(...)"
				//       is not available in old environment.
				//
				//       Hence, we get an instance of Locale in non-simplest way.
				//       Don't refactor the following code, for the time being.

				// If the value contains "-" (excluding the head or the tail), it is the separator between a language code and a country code.
				// So split the value by "-" and pass them to the construction of the Locale class independently.
				// For example, if "en-US" is specified, split it to { "en", "US" }.
				if (0 < optionValue.indexOf("-") && optionValue.indexOf("-") < optionValue.length()-1) {
					if (optionValue.toLowerCase().equals("ja-jp")) {
						this.locale = Locale.JAPANESE;
					} else {
						this.locale = Locale.ENGLISH;
					}

				// Otherwise, we regard the value as a language code, so simply pass it to the constructor of the Locale class.
				} else {
					if (optionValue.toLowerCase().equals("ja") || optionValue.toLowerCase().equals("jp")) {
						this.locale = Locale.JAPANESE;
					} else {
						this.locale = Locale.ENGLISH;
					}
				}
				this.engineOptionMap.put(OptionKey.LOCALE, this.locale);
				return true;
			}

			// --encoding option:
			case COMMAND_OPTNAME_ENCODING : {
				// This option is detected and handled in dispatch() method, so do nothing here.
				return true;
			}

			// --dump option:
			case COMMAND_OPTNAME_DUMP : {
				if (optionValue == null) {
					optionValue = DUMP_TARGET_DEFAULT;
				}
				String convertedOptionValue = null;
				if (DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.containsKey(optionValue)) {
					convertedOptionValue = DUMP_TARGET_COMMANDOPT_ENGINEOPT_MAP.get(optionValue);
				} else {
					System.err.println("Invalid value for " + COMMAND_OPTNAME_PREFIX + COMMAND_OPTNAME_DUMP + " option: " + optionValue);
					return false;
				}
				this.engineOptionMap.put(OptionKey.DUMPER_TARGET, convertedOptionValue);
				this.engineOptionMap.put(OptionKey.DUMPER_ENABLED, Boolean.TRUE);
				return true;
			}

			// --perf option:
			case COMMAND_OPTNAME_PERF : {
				this.perfEnabled = true;
				if (optionValue == null) {
					optionValue = PERF_TARGET_DEFAULT;
				}
				if (PERF_TARGET_SET.contains(optionValue)) {
					this.perfTarget = optionValue;
				} else {
					System.err.println(
						"Invalid value for " + COMMAND_OPTNAME_PREFIX + COMMAND_OPTNAME_PERF + "option: " + optionValue
					);
					return false;
				}
				this.engineOptionMap.put(OptionKey.PERFORMANCE_MONITOR_ENABLED, Boolean.TRUE);
				return true;
			}

			// --pluginDir option:
			case COMMAND_OPTNAME_PLUGIN_DIR : {

				// Split the specified value by the path-separator (":" or ";", depending on the user's environment).
				String[] pluginDirs = new String[0];
				if (optionValue != null) {
					pluginDirs = optionValue.split(System.getProperty("path.separator"));
				}

				// Store the splitted values to the optPluginDirList.
				for (String pluginDir: pluginDirs) {
					this.optPluginDirList.add(pluginDir);
				}
				return true;
			}

			// --plugin option:
			case COMMAND_OPTNAME_PLUGIN : {

				// Split the specified value by the path-separator (":" or ";", depending on the user's environment),
				String[] pluginPaths = new String[0];
				if (optionValue != null) {
					pluginPaths = optionValue.split(System.getProperty("path.separator"));
				}

				// Converts plugin directories (specified by --pluginDir option) to URLs.
				String[] pluginDirs = new String[] { DEFAULT_PLUGIN_DIR };
				if (0 < this.optPluginDirList.size()) {
					pluginDirs = this.optPluginDirList.toArray(new String[0]);
				}
				int pluginDirLength = pluginDirs.length;
				URL[] pluginDirURLs = new URL[pluginDirLength];
				for (int dirIndex=0; dirIndex<pluginDirLength; dirIndex++) {
					try {
						pluginDirURLs[dirIndex] = new File(pluginDirs[dirIndex]).toURI().toURL();
					} catch (MalformedURLException e) {
						System.err.print("Invalid plugin directory: " + pluginDirs[dirIndex]);
						return false;
					}
				}

				// Create an class loader for loading classes from the above plugin directories.
				URLClassLoader classLoader = new URLClassLoader(pluginDirURLs);

				// Create a plugin loader which uses the above class loader internally.
				ConnectorImplementationLoader pluginLoader = new ConnectorImplementationLoader(classLoader);

				// Load all plugins, and store instances of them to the optPluginList.
				for (String pluginPath: pluginPaths) {
					try {
						ConnectorImplementationContainer pluginContainer = pluginLoader.load(pluginPath);
						Object plugin = pluginContainer.getConnectorImplementation();
						this.optPluginList.add(plugin);
					} catch (ConnectorException e) {
						System.err.println("Plug-in connection failed: " + pluginPath);
						e.printStackTrace();
					}
				}

				return true;
			}

			// --pluginList option:
			case COMMAND_OPTNAME_PLUGIN_LIST : {
				this.optPluginListFilePath = optionValue;
				return true;
			}

			// --libList option:
			case COMMAND_OPTNAME_LIBRARY_LIST : {
				this.optLibraryListFilePath = optionValue;
				return true;
			}

			// --libList option:
			case COMMAND_OPTNAME_PERMISSION : {
				if (optionValue == null) {
					System.err.println("No value is specified for --" + COMMAND_OPTNAME_PERMISSION + " option.");
					return false;
				}
				switch (optionValue) {
					case PERMISSION_VALUE_DENY_ALL : {
						this.permissionMap = PERMISSION_MAP_DENY_ALL;
						return true;
					}
					case PERMISSION_VALUE_ALLOW_ALL : {
						this.permissionMap = PERMISSION_MAP_ALLOW_ALL;
						return true;
					}
					case PERMISSION_VALUE_ASK_ALL : {
						this.permissionMap = PERMISSION_MAP_ASK_ALL;
						return true;
					}
					case PERMISSION_VALUE_BALANCED : {
						this.permissionMap = PERMISSION_MAP_BALANCED;
						return true;
					}
					default: {
						System.err.println("Invalid value for --" + COMMAND_OPTNAME_PERMISSION + " option: " + optionValue);
						return false;
					}
				}
			}

			// --test option:
			case COMMAND_OPTNAME_TEST : {
				// Enable the flag to run tests.
				// This flag will be referred in dispatch() method, and tests will be executed in there if this flag is true.
				this.optCombinedTestRequired = true;
				return true;
			}

			// Other options: error
			default : {
				System.err.println("Unknown option name: " + optionName);
				return false;
			}
		}
	}


	/**
	 * Parses the specified command line arguments,
	 * and returns a Map in which names (keys) and values of command line options are stored.
	 *
	 * @param args The command line arguments.
	 * @return The Map in which names (keys) and values of command line options are stored.
	 */
	private Map<String, String> parseArguments(String[] args) {
		int argLength = args.length;

		List<String> optionNameList = new ArrayList<String>();

		// The Map to be returned.
		Map<String, String> optionNameValueMap = new LinkedHashMap<String, String>();

		// The flag representing whether the currently parsed argument is an explicit option (is not the default option).
		boolean currentArgIsExplicitOption = false;

		// Stores the name of the currently parsed option.
		String currentOptionName = null;

		// Parse each argument:
		for (int argIndex=0; argIndex<argLength; argIndex++) {

			// If the arg starts with the prefix "--", it is an option name.
			if (args[argIndex].startsWith(COMMAND_OPTNAME_PREFIX)) {
				currentArgIsExplicitOption = true;
				currentOptionName = args[argIndex].substring(COMMAND_OPTNAME_PREFIX.length(), args[argIndex].length());
				optionNameList.add(currentOptionName);

			// Otherwise, the arg is a option value.
			} else {

				// If the previous arg is an option name (currentArgIsExplicitOption is true),
				// set this arg to the Map, as a value corresponding with the above option name.
				if (currentArgIsExplicitOption) {
					optionNameValueMap.put(currentOptionName, args[argIndex]);

				// Otherwise, set this arg to the Map, as a value of the default option (--file).
				} else {
					optionNameValueMap.put(COMMAND_OPTNAME_DEFAULT, args[argIndex]);
				}

				// Reset the flag and the temporary variable.
				currentArgIsExplicitOption = false;
				currentOptionName = null;
			}
		}

		// For options of which only names are specified (without values), set null as values.
		for (String optionName: optionNameList) {
			if (!optionNameValueMap.containsKey(optionName)) {
				optionNameValueMap.put(optionName, null);
			}
		}

		return optionNameValueMap;
	}


	/**
	 * Creates an initialized VnanoEngine.
	 * The initialization taken by this method contains option settings and plugin loadings.
	 *
	 * @param optionMap The Map in which option names (as keys) and values are stored.
	 * @param permissionMap The Map in which permission item names (as keys) and values are stored.
	 * @param pluginLoader The loader of plugins.
	 * @return The initialized VnanoEngine.
	 */
	private VnanoEngine createInitializedVnanoEngine(
			Map<String, Object> optionMap, Map<String, String> permissionMap, PluginLoader pluginLoader) {

		VnanoEngine engine = new VnanoEngine();

		// Plugins may access to option/permission settings,
		// so firstly set options/permissions to the engine before loading plugins.
		try {
			engine.setOptionMap(optionMap);
			engine.setPermissionMap(permissionMap);
		} catch (VnanoException e) {
			System.out.println("Invalid option/permission settings have been detected.");
			e.printStackTrace();
			return null;
		}

		// Connect the default plugins.
		try {
			ScriptIO ioInstance = new ScriptIO();
			engine.connectPlugin(SpecialBindingKey.AUTO_KEY, new Object[]{ ScriptIO.class.getMethod("output",long.class    ), ioInstance } );
			engine.connectPlugin(SpecialBindingKey.AUTO_KEY, new Object[]{ ScriptIO.class.getMethod("output",double.class ), ioInstance } );
			engine.connectPlugin(SpecialBindingKey.AUTO_KEY, new Object[]{ ScriptIO.class.getMethod("output",boolean.class), ioInstance } );
			engine.connectPlugin(SpecialBindingKey.AUTO_KEY, new Object[]{ ScriptIO.class.getMethod("output",String.class ), ioInstance } );
			engine.connectPlugin(SpecialBindingKey.AUTO_KEY, new Object[]{ ScriptIO.class.getMethod("time"), ioInstance } );

		} catch (NoSuchMethodException e){
			System.err.println("Method/field not found.");
			e.printStackTrace();
			return null;
		} catch (VnanoException e){
			System.err.println("Plug-in connection failed.");
			e.printStackTrace();
			return null;
		}

		// Connect the other plugins, which are registered to the specified plugin loader.
		try {
			pluginLoader.load();
			if (pluginLoader.hasPlugins()) {
				String[] pluginNames = pluginLoader.getPluginNames();
				Object[] pluginInstances = pluginLoader.getPluginInstances();
				int pluginN = pluginNames.length;
				for (int pluginIndex=0; pluginIndex<pluginN; pluginIndex++) {
					engine.connectPlugin("___VNANO_AUTO_KEY", pluginInstances[pluginIndex]); // Generate a syntactically valid key automatically.
				}
			}
		} catch (VnanoException e) {
			System.err.println("Plug-in load failed.");
			e.printStackTrace();
		}

		return engine;
	}


	/**
	 * Creates an initialized Interconenct.
	 * The initialization taken by this method contains option settings and plugin loadings.
	 *
	 * @param optionMap The Map in which option names (as keys) and values are stored.
	 * @param permissionMap The Map in which permission item names (as keys) and values are stored.
	 * @param pluginLoader The loader of plugins.
	 * @return The initialized Interconenct.
	 */
	private Interconnect createInitializedInterconnect(
			Map<String, Object> optionMap, Map<String, String> permissionMap, PluginLoader pluginLoader) {

		Interconnect interconnect = new Interconnect();

		// Plugins may access to option/permission settings,
		// so firstly set options/permissions to the engine before loading plugins.
		try {
			interconnect.setOptionMap(optionMap);
			interconnect.setPermissionMap(permissionMap);
		} catch (VnanoException e) {
			System.out.println("Invalid option/permission settings have been detected.");
			e.printStackTrace();
		}

		// Connect the default plugins.
		try {
			ScriptIO ioInstance = new ScriptIO();
			interconnect.connectPlugin("output(int)",    new Object[]{ ScriptIO.class.getMethod("output",long.class    ), ioInstance } );
			interconnect.connectPlugin("output(float)",  new Object[]{ ScriptIO.class.getMethod("output",double.class ), ioInstance } );
			interconnect.connectPlugin("output(bool)",   new Object[]{ ScriptIO.class.getMethod("output",boolean.class), ioInstance } );
			interconnect.connectPlugin("output(string)", new Object[]{ ScriptIO.class.getMethod("output",String.class ), ioInstance } );
			interconnect.connectPlugin("time()",         new Object[]{ ScriptIO.class.getMethod("time"), ioInstance } );

		} catch (NoSuchMethodException e){
			System.err.println("Method/field not found.");
			e.printStackTrace();
			return null;
		} catch (VnanoException e) {
			System.err.println("Method/field could not be connected.");
			e.printStackTrace();
		}

		// Connect the other plugins, which are registered to the specified plugin loader.
		try {
			pluginLoader.load();
			if (pluginLoader.hasPlugins()) {
				String[] pluginNames = pluginLoader.getPluginNames();
				Object[] pluginInstances = pluginLoader.getPluginInstances();
				int pluginN = pluginNames.length;
				for (int pluginIndex=0; pluginIndex<pluginN; pluginIndex++) {
					interconnect.connectPlugin(pluginNames[pluginIndex], pluginInstances[pluginIndex]);
				}
			}
		} catch (VnanoException e) {
			System.err.println("Plug-in load failed.");
			e.printStackTrace();
		}

		return interconnect;
	}


	/**
	 * Executes combined tests of the whole VnanoEngine (not containing unit tests of component classes).
	 */
	private boolean executeCombinedTest() {
		VnanoEngine engine = this.createInitializedVnanoEngine(
			this.engineOptionMap, this.permissionMap, new PluginLoader(DEFAULT_ENCODING)
		);

		try {
			CombinedTestExecutor testExecutor = new CombinedTestExecutor();
			testExecutor.test(engine);
			return true;
		} catch (CombinedTestException e) {
			System.err.println("Combined test failed.");
			System.err.println("");
			System.err.println("[ Stack Trace ]");
			e.printStackTrace();
			System.err.println("");
			if (!this.engineOptionMap.containsKey(OptionKey.DUMPER_ENABLED)) {
				System.err.println("For more debug information, re-execute combined tests with \"--dump\" option.");
			}
			return false;
		}
	}


	/**
	 * Execute the specified Vnano script file or VRIL assembly file.
	 *
	 * @param inputFilePath The path of the file to be executed.
	 * @param libraryListFilePath The path of the library list file.
	 * @param pluginListFilePath The path of the plugin list file.
	 * @param defaultEncoding The encoding used when no encoding-declaration line exists in the above files.
	 */
	private void executeFile(
			String inputFilePath, String libraryListFilePath, String pluginListFilePath, String defaultEncoding)
					throws VnanoException {

		// Load the main script and libraries.
		ScriptLoader scriptLoader = new ScriptLoader(defaultEncoding);
		scriptLoader.setMainScriptPath(inputFilePath);
		if (libraryListFilePath != null) {
			scriptLoader.setLibraryScriptListPath(libraryListFilePath);
		}
		scriptLoader.load();

		// Load plugins.
		PluginLoader pluginLoader = new PluginLoader(defaultEncoding);
		if (pluginListFilePath != null) {
			pluginLoader.setPluginListPath(pluginListFilePath);
		}
		pluginLoader.load();

		// Execute the specified script/assembly file.
		if (inputFilePath.endsWith(EXTENSION_VNANO)) {
			this.executeVnanoScriptFile(scriptLoader, pluginLoader);
		} else if (inputFilePath.endsWith(EXTENSION_VRIL)) {
			this.executeVrilCodeFile(scriptLoader, pluginLoader);
		} else {
			System.err.println("Unknown file type (extension): " + inputFilePath);
		}
	}


	/**
	 * Execute the specified Vnano script file.
	 *
	 * @param scriptLoader The script loader in which the main script and library scripts are registered (already loaded).
	 * @param pluginLoader The plugin loader in which all plugins to be connected are registered (already loaded).
	 */
	public void executeVnanoScriptFile(ScriptLoader scriptLoader, PluginLoader pluginLoader) throws VnanoException {

		// Set the name of the script to the option map.
		// (The "import path" of the main script should not be a relative path form, so specify only the name, not path.)
		this.engineOptionMap.put(OptionKey.MAIN_SCRIPT_NAME, scriptLoader.getMainScriptName());

		// Set the UI_MODE option to CUI mode.
		// It may be referred in initialization processes of plugins, so we should set before connecting plugins.
		this.engineOptionMap.put(OptionKey.UI_MODE, "CUI");

		// Normalize contents of the option map.
		// (Mandatory options are suppremented by default values, if they are not specified.)
		this.engineOptionMap = OptionValue.normalizeValuesOf(this.engineOptionMap);

		// Create an initialized VnanoEngine,
		// where the "initialization" contains option settings and plugin loadings.
		VnanoEngine engine = this.createInitializedVnanoEngine(this.engineOptionMap, this.permissionMap, pluginLoader);

		// Register library scripts to be "include"-ed.
		if (scriptLoader.hasLibraryScripts()) {
			String[] libPaths = scriptLoader.getLibraryScriptPaths(true);
			String[] libContents = scriptLoader.getLibraryScriptContents();
			int libN = libPaths.length;
			for (int libIndex=0; libIndex<libN; libIndex++) {
				engine.registerLibraryScript(libPaths[libIndex], libContents[libIndex]);
			}
		}

		// If the --perf option is enabled, create resources to measure/print performance values.
		PerformanceValuePrinter perfValuePrinter = null;
		if (this.perfEnabled) {
			boolean printsVmSpeed = this.perfTarget.equals(PERF_TARGET_ALL) || this.perfTarget.equals(PERF_TARGET_SPEED);
			boolean printsRamUsage = this.perfTarget.equals(PERF_TARGET_ALL) || this.perfTarget.equals(PERF_TARGET_RAM);
			boolean printsInstructionFreq = this.perfTarget.equals(PERF_TARGET_ALL) || this.perfTarget.equals(PERF_TARGET_INSTRUCTION_FREQ);
			perfValuePrinter = new PerformanceValuePrinter(
				engine, printsVmSpeed, printsRamUsage, printsInstructionFreq // そろそろ setter にしたほうが
			);
			Thread perfValuePrintThread = new Thread(perfValuePrinter);
			perfValuePrintThread.start();
		}

		// Execute the main script.
		engine.executeScript(scriptLoader.getMainScriptContent());

		// When the process of the script has completed, terminate the performance measurement.
		// Note that, if we don't terminate it, the performance measuring thread will not be released.
		if (this.perfEnabled) {
			perfValuePrinter.terminate();
		}

		// Disconnect all plugins.
		engine.disconnectAllPlugins();
	}


	/**
	 * Execute the specified VRIL assembly file.
	 *
	 * @param scriptLoader The script loader in which the VRIL assembly code and library scripts are registered (already loaded).
	 * @param pluginLoader The plugin loader in which all plugins to be connected are registered (already loaded).
	 */
	public void executeVrilCodeFile(ScriptLoader scriptLoader, PluginLoader pluginLoader) throws VnanoException {

		// Set the name of the script to the option map.
		this.engineOptionMap.put(OptionKey.MAIN_SCRIPT_NAME, scriptLoader.getMainScriptName());

		// Set the UI_MODE option to CUI mode.
		// It may be referred in initialization processes of plugins, so we should set before connecting plugins.
		this.engineOptionMap.put(OptionKey.UI_MODE, "CUI");

		// Normalize contents of the option map.
		// (Mandatory options are suppremented by default values, if they are not specified.)
		this.engineOptionMap = OptionValue.normalizeValuesOf(this.engineOptionMap);

		// Create an initialized Interconnect,
		// where the "initialization" contains option settings and plugin loadings.
		Interconnect interconnect = this.createInitializedInterconnect(this.engineOptionMap, this.permissionMap, pluginLoader);
		if (interconnect == null) {
			return;
		}

		// Invoke initialization processes of the connected plugins.
		interconnect.activate();

		// Create a VirtualMachine, which can directly execute VRIL assembly code.
		VirtualMachine vm = new VirtualMachine();

		// If the --perf option is enabled, create resources to measure/print performance values.
		PerformanceValuePrinter perfValuePrinter = null;
		if (this.perfEnabled) {
			boolean printsVmSpeed = this.perfTarget.equals(PERF_TARGET_ALL) || this.perfTarget.equals(PERF_TARGET_SPEED);
			boolean printsRamUsage = this.perfTarget.equals(PERF_TARGET_ALL) || this.perfTarget.equals(PERF_TARGET_RAM);
			boolean printsInstructionFreq = this.perfTarget.equals(PERF_TARGET_ALL) || this.perfTarget.equals(PERF_TARGET_INSTRUCTION_FREQ);
			perfValuePrinter = new PerformanceValuePrinter(vm, printsVmSpeed, printsRamUsage, printsInstructionFreq);
			Thread perfValuePrintThread = new Thread(perfValuePrinter);
			perfValuePrintThread.start();
		}

		// Execute the VRIL assembly code.
		vm.executeAssemblyCode(scriptLoader.getMainScriptContent(), interconnect);

		// When the process of the VRIL assembly code has completed, terminate the performance measurement.
		// Note that, if we don't terminate it, the performance measuring thread will not be released.
		if (this.perfEnabled) {
			perfValuePrinter.terminate();
		}

		// Invoke finalization processes of the connected plugins.
		interconnect.deactivate();

		// Disconnect all plugins.
		interconnect.disconnectAllPlugins();
	}


	/**
	 * Dump (print) the information of the specified Exception.
	 *
	 * @param e The Exception to be dumped (printed).
	 */
	public void dumpException(Exception e) {
		e.printStackTrace();
		System.err.println("");
	}
}
