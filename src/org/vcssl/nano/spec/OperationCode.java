/*
 * Copyright(C) 2017-2018 RINEARN (Fumihiro Matsui)
 * This software is released under the MIT License.
 */

package org.vcssl.nano.spec;

/**
 * <p>
 * 仮想プロセッサにおける、命令のオペレーションコードが定義された列挙子です。
 * </p>
 *
 * @author RINEARN (Fumihiro Matsui)
 */
public enum OperationCode {

	/**
	 * 加算命令です。
	 *
	 * 中間アセンブリコード内での構文は「 ADD type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータが加算され、
	 * 結果が output のデータに格納されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランドの配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 */
	ADD,


	/**
	 * 減算命令です。
	 *
	 * 中間アセンブリコード内での構文は「 SUB type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータが減算され、
	 * 結果が output のデータに格納されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 */
	SUB,


	/**
	 * 乗算命令です。
	 *
	 * 中間アセンブリコード内での構文は「 SUB type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータが乗算され、
	 * 結果が output のデータに格納されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 */
	MUL,


	/**
	 * 除算命令です。
	 *
	 * 中間アセンブリコード内での構文は「 MUL type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータが inputB のデータで除算され、
	 * 結果が output のデータに格納されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 */
	DIV,


	/**
	 * 剰余算命令です。
	 *
	 * 中間アセンブリコード内での構文は「 DIV type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータを、inputB のデータで除算した剰余が計算され、
	 * 結果が output のデータに格納されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 */
	REM,


	/**
	 * 符号反転命令です。
	 *
	 * 中間アセンブリコード内での構文は「 NEG type output input; 」です。
	 * この命令の実行により、input のデータの符号反転を行った結果が、
	 * output のデータに格納されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 */
	NEG,


	/**
	 * 等値比較命令です。
	 *
	 * 中間アセンブリコード内での構文は「 EQ type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと、inputB のデータの等値比較が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA および inputB が一致している場合に true、一致しない場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、inputA および inputB のデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 * output のデータ型は必ず {@link DataType#BOOL BOOL} 型）である必要があります。
	 */
	EQ,


	/**
	 * 非等値比較命令です。
	 *
	 * 中間アセンブリコード内での構文は「 NEQ type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと、inputB のデータの非等値比較が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA および inputB が一致しない場合に true、一致する場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、inputA および inputB のデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 * output のデータ型は必ず {@link DataType#BOOL BOOL} 型である必要があります。
	 */
	NEQ,


	/**
	 * 大なり比較命令です。
	 *
	 * 中間アセンブリコード内での構文は「 GT type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータの大なり比較が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA のデータの値が、inputB のものより大きい（等値を含まない）場合に true、
	 * そうでしない場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、inputA および inputB のデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 * output のデータ型は必ず {@link DataType#BOOL BOOL} 型である必要があります。
	 */
	GT,


	/**
	 * 大なり比較命令です。
	 *
	 * 中間アセンブリコード内での構文は「 LT type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータの小なり比較が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA のデータの値が、inputB のものより小さい（等値を含まない）場合に true、
	 * そうでしない場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、inputA および inputB のデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 * output のデータ型は必ず {@link DataType#BOOL BOOL} 型である必要があります。
	 */
	LT,


	/**
	 * 大なり等値比較命令です。
	 *
	 * 中間アセンブリコード内での構文は「 GEQ type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータの大なり等値比較が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA のデータの値が、inputB のものより大きいか等しい場合に true、
	 * そうでしない場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、inputA および inputB のデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 * output のデータ型は必ず {@link DataType#BOOL BOOL} 型である必要があります。
	 */
	GEQ,


	/**
	 * 小なり等値比較命令です。
	 *
	 * 中間アセンブリコード内での構文は「 LEQ type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータの小なり等値比較が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA のデータの値が、inputB のものより小さいか等しい場合に true、
	 * そうでしない場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、inputA および inputB のデータ型は揃っている必要があり、
	 * そのデータ型を type に指定します。
	 * output のデータ型は必ず {@link DataType#BOOL BOOL} 型である必要があります。
	 */
	LEQ,


	/**
	 * 論理積命令です。
	 *
	 * 中間アセンブリコード内での構文は「 AND type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータの論理積が計算が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA のデータの値と、inputB のデータの値が両者共に true である場合に true、
	 * そうでない場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は全て {@link DataType#BOOL BOOL} 型に揃っている必要があり、
	 * type にも BOOL が指定されている必要があります。
	 */
	AND,


	/**
	 * 論理和命令です。
	 *
	 * 中間アセンブリコード内での構文は「 OR type output inputA inputB; 」です。
	 * この命令の実行により、inputA のデータと inputB のデータの論理和が計算が行われ、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、inputA のデータの値と、inputB のデータの値の、 少なくとも片方が true
	 * である場合に true、両者とも false である場合に false となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は全て {@link DataType#BOOL BOOL} 型に揃っている必要があり、
	 * type にも BOOL が指定されている必要があります。
	 */
	OR,


	/**
	 * 論理否定命令です。
	 *
	 * 中間アセンブリコード内での構文は「 NOT type output input; 」です。
	 * この命令の実行により、input のデータの論理否定値が計算され、
	 * 結果が output のデータに格納されます。
	 * 演算結果は、input のデータの値が true である場合に false、
	 * 逆に false である場合に true となります。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は全て {@link DataType#BOOL BOOL} 型に揃っている必要があり、
	 * type にも BOOL が指定されている必要があります。
	 */
	NOT,


	/**
	 * 代入命令です。
	 *
	 * 中間アセンブリコード内での構文は「 MOV type output input; 」です。
	 * この命令の実行により、input のデータの複製値が、
	 * output のデータに代入されます。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 * また、全オペランドのデータ型は、
	 * type に指定されたものに揃っている必要があります。
	 */
	MOV,


	/**
	 * (暫定)参照代入命令です。
	 */
	REF,


	/**
	 * (暫定)スタックからの代入命令です。
	 */
	MOVPOP,


	/**
	 * (暫定)スタックからの参照代入命令です。
	 */
	REFPOP,


	/**
	 * メモリー確保命令です。
	 *
	 * この命令は可変長オペランドを取り、中間アセンブリコード内での構文は
	 * 「 ALLOC type target len1 len2 len3 ... lenN; 」で、
	 * len1 から lenN までのオペランドの個数が任意になっています。
	 * これらのオペランドを次元長オペランド（後述）と呼びます。
	 * <br >
	 * この命令の実行により、target がデータを格納できるようにメモリー領域が確保されます。
	 * type の箇所には、格納したいデータの型を指定します。
	 * （即ち、この命令は型付けの機能を兼ねています）。
	 * <br >
	 * 次元長オペランドには、確保するメモリー領域の、
	 * 多次元配列としての次元ごとの長さを、並べて指定します。
	 * <br >
	 * 次元長オペランドが無い場合、つまり「 ALLOC type target 」の場合は、
	 * スカラ値を格納する領域が確保されます。これは、この処理系において、
	 * スカラを0次元の配列として扱う事に対応しています。
	 * <br >
	 * また、次元長オペランドが1個の場合、つまり「 ALLOC type target len 」の場合は、
	 * 1次元の配列 [len] を格納する領域が確保されます。
	 * <br >
	 * 同様に、次元長オペランドが3個の場合、つまり「 ALLOC type target len1 len2 len3 」の場合は、
	 * 3次元の配列 [len1][len2][len3] を格納する領域が確保されます。
	 * 4次元以上の配列についても同様に、要素数オペランドを右に追加していきます。
	 * <br >
	 * 次元長オペランド（len1, len2, ...）のデータ型については、
	 * 必ず {@link DataType#INT64 INT64} 型である必要があります。
	 */
	ALLOC,


	/**
	 * メモリー確保命令であり、{@link OperationCode#ALLOC ALLOC} 命令の派生命令です。
	 *
	 * この命令は {@link OperationCode#ALLOC ALLOC} 命令とは違って固定長で、
	 * 中間アセンブリコード内での構文は「 ALLOC type target sample; 」です。
	 * この命令の実行により、target がデータを格納できるようにメモリー領域が確保されます。
	 * その際、確保する領域の次元数や次元ごとの長さは、
	 * sample に指定したオペランドの次元数や次元ごとの長さと同一になります。
	 * sample からは、それ以外の情報（実際に格納しているデータの内容や型など）は参照されません。
	 * type の箇所には、格納したいデータの型を指定します。
	 * （即ち、この命令は型付けの機能を兼ねています）。
	 * <br >
	 * この命令は特に、演算結果を格納するレジスタ領域を確保するために用いられます。
	 * その理由は、ベクトル演算も含めて一般に、
	 * 演算結果のデータは演算対象の入力データと、同次元かつ同じ長さになるパターンが多いためです。
	 * ただし、この ALLOCR 命令自体はレジスタ以外に対しても使用できます。
	 */
	ALLOCR,


	/**
	 * メモリー確保命令であり、{@link OperationCode#ALLOC ALLOC} 命令の派生命令です。
	 *
	 * この命令は {@link OperationCode#ALLOC ALLOC} 命令とは違って固定長で、
	 * 中間アセンブリコード内での構文は「 ALLOCP type target; 」です。
	 * この命令の実行により、target がデータを格納できるようにメモリー領域が確保されます。
	 * その際、確保する領域の次元数や次元ごとの長さは、
	 * スタック上の先端に積まれているデータにおける、次元数や次元ごとの長さと同一になります。
	 * スタック上のデータから、それ以外の情報（実際に格納しているデータの内容や型など）は参照されません。
	 * type の箇所には、格納したいデータの型を指定します。
	 * （即ち、この命令は型付けの機能を兼ねています）。
	 * なお、この命令を実行しても、スタック上からデータは削除されません。
	 * <br >
	 * この命令は特に、関数の引数や戻り値をスタックから取り出す際に、
	 * 取り出したデータの格納先のメモリー領域を確保するために使用されます。
	 */
	ALLOCP,


	/**
	 * メモリー解放命令です。
	 *
	 * 中間アセンブリコード内での構文は「 FREE type target; 」です。
	 * この命令の実行により、target のデータを保持するメモリー領域が解放されます。
	 * type には target のデータ型を指定します。
	 */
	FREE,


	/**
	 * 型変換命令です。
	 *
	 * 中間アセンブリコード内での構文は「 CAST toType:fromType output input; 」です。
	 * この命令の実行により、inputのデータが型変換されつつ、outputのデータに代入されます。
	 * input のデータ型を fromType に、output のデータ型を toType に指定します。
	 * <br >
	 * この命令はベクトル演算命令であり、全オペランド（outputを含む）
	 * の配列要素数が同一に揃っている必要があります
	 * （スカラは要素数1かつ0次元の配列として演算されます）。
	 */
	CAST,


	/**
	 * 整列代入命令です。
	 */
	REORD,


	/**
	 * 全要素代入命令です。
	 */
	FILL,


	/**
	 * 要素参照命令です。
	 */
	ELEM,


	/**
	 * 真値分岐命令です。
	 */
	JMP, // オペランドが true の場合に飛ぶ。else などで使用。あと命名規則的にもJMPNのNじゃない版として必要。


	/**
	 * 偽値分岐命令です。
	 */
	JMPN, // オペランドがfalse時の飛ぶ。普通の利用場面ではこちらの方が多い。


	/**
	 * 内部関数呼び出し命令です。
	 */
	CALL,


	/**
	 * 外部関数呼び出し命令です。
	 */
	CALLX,


	/**
	 * 内部関数での引数取得命令です。
	 */
	ARG,


	/**
	 * 内部関数からのリターン命令です。
	 */
	RET,


	/**
	 * 拡張命令です。
	 *
	 * この命令は、{@link org.vcssl.nano.vm.processor} パッケージが提供する標準の仮想プロセッサでは処理されません。
	 * より上層に機能拡張された仮想プロセッサを設けて、標準命令（この列挙子に定義されている、他の全ての命令）
	 * の範囲を超えた処理を行いたい場合に使用します。
	 * <br />
	 * 拡張命令のオペレーションコードなどは、
	 * {@link org.vcssl.nano.vm.processor.Instruction Instruction} クラスの
	 * {@link org.vcssl.nano.vm.processor.Instruction#extention extention}
	 * フィールドに保持される拡張命令情報オブジェクトに格納して指定します。
	 * <br />
	 * 例として、{@link org.vcssl.nano.vm.accelerator} パッケージによって提供される高速版の仮想プロセッサ実装では、
	 * データ型に応じて最適化された算術演算命令などに、この拡張命令の仕組みが使用されています。
	 */
	EX,


	/**
	 * 何も行わない命令です。
	 * ただし、処理系内部では、他の命令と同様に、命令ディスパッチの段階までの処理は行われます。
	 * そこでディスパッチされる処理が、何もしない内容になっています。
	 * 処理系の高速化などにおいて、命令ディスパッチの段階までの処理コストを見積もるためなどに使用されます。
	 */
	NOP,

}
