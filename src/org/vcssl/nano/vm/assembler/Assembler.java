/*
 * Copyright(C) 2017-2022 RINEARN
 * This software is released under the MIT License.
 */

package org.vcssl.nano.vm.assembler;

import org.vcssl.nano.VnanoFatalException;
import org.vcssl.nano.VnanoException;
import org.vcssl.nano.interconnect.AbstractFunction;
import org.vcssl.nano.interconnect.AbstractVariable;
import org.vcssl.nano.interconnect.FunctionTable;
import org.vcssl.nano.interconnect.Interconnect;
import org.vcssl.nano.interconnect.VariableTable;
import org.vcssl.nano.spec.AssemblyWord;
import org.vcssl.nano.spec.DataType;
import org.vcssl.nano.spec.DataTypeName;
import org.vcssl.nano.spec.ErrorType;
import org.vcssl.nano.spec.LiteralSyntax;
import org.vcssl.nano.spec.OperationCode;
import org.vcssl.nano.vm.VirtualMachineObjectCode;
import org.vcssl.nano.vm.memory.Memory;
import org.vcssl.nano.vm.memory.DataContainer;
import org.vcssl.nano.vm.processor.Instruction;


/**
 * The class performing the function of a assembler,
 * in the virtual machine of the script engine of the Vnano.
 * 
 * The assembler provided by this class converts the VRIL assembly code generated by the compiler 
 * to an instance of {@link org.vcssl.nano.vm.VirtualMachineObjectCode VirtualMachineObjectCode}
 * (VM object code).
 */
public class Assembler {

	/**
	 * Create a new assembler.
	 */
	public Assembler() {
	}


	/**
	 * Convert the VRIL assembly code to the instance of 
	 * {@link org.vcssl.nano.vm.VirtualMachineObjectCode VirtualMachineObjectCode}(VM object code).
	 * 
	 * @param assemblyCode The VRIL assembly code to be converted.
	 * @param Intterconnect The interconnect having external variables/functions referred from the VRIL assembly code.
	 * @return The generated VM object code.
	 * @throws VnanoException Thrown when any error in the content of the VRIL assembly code has been detected.
	 */
	public VirtualMachineObjectCode assemble(String assemblyCode, Interconnect interconnect) throws VnanoException {

		// Replace all string literals in the code to the numberized literal: "1", "2", ...
		String[] stringLiteralExtractResult = LiteralSyntax.extractStringLiterals(assemblyCode);
		assemblyCode = stringLiteralExtractResult[0]; // [0] 番に置き換え済みコードが格納されている（1番以降はリテラル内容）

		// Put LABEL instructions at locations of labels and CALL instructions, for making optimization easy.
		assemblyCode = this.appendLabelInstructions(assemblyCode);

		// Get variable/function tables from the interconnect.
		VariableTable globalVariableTable = interconnect.getExternalVariableTable();
		FunctionTable functionTable = interconnect.getExternalFunctionTable();

		VirtualMachineObjectCode vmObjectCode = this.preprocessDirectives(assemblyCode, globalVariableTable, functionTable);
		int registerMaxAddress = 0;

		int constantAddress = 0;

		String[] lines = assemblyCode.split(AssemblyWord.INSTRUCTION_SEPARATOR_REGEX);
		int lineLength = lines.length;

		int metaAddress = -1;

		String sourceFileName = "(none)";
		int sourceLineNumber = -1;

		for (int i=0; i<lineLength; i++) {

			String line = lines[i].trim();
			if (line.length() == 0) {
				continue;
			}

			String[] words = line.split(AssemblyWord.WORD_SEPARATOR_REGEX);
			int wordLength = words.length;

			// Meta directive: generate constant data storing the meta information.
			if (line.startsWith(AssemblyWord.META_DIRECTIVE)) {

				// Recover the content of the string literal from the numberized literal.
				int stringLiteralIndex = LiteralSyntax.getIndexOfNumberedStringLiteral(words[1].trim());
				String originalStringLiteral = stringLiteralExtractResult[ stringLiteralIndex ];

				// Store the content of the string literal to a data container, 
				// and register it as a constant data to the vmObjectCode.
				String metaImmediateValue
					= Character.toString(AssemblyWord.IMMEDIATE_OPERAND_PREFIX)
					+ DataTypeName.getDataTypeNameOf(DataType.STRING)
					+ AssemblyWord.VALUE_SEPARATOR
					+ originalStringLiteral;
				DataContainer<?> dataContainer = this.parseImmediateValue(metaImmediateValue);
				vmObjectCode.addConstantData(metaImmediateValue, dataContainer, constantAddress);
				metaAddress = constantAddress;
				constantAddress++;
				continue;

			} else if (line.startsWith(Character.toString(AssemblyWord.DIRECTIVE_PREFIX))) {
				continue;
			}


			OperationCode operationCode = OperationCode.valueOf(words[0]);

			String[] dataTypeNames = words[1].split(AssemblyWord.VALUE_SEPARATOR_REGEX);
			int dataTypeLength = dataTypeNames.length;
			DataType[] dataTypes = new DataType[dataTypeLength];
			for (int dataTypeIndex=0; dataTypeIndex<dataTypeLength; dataTypeIndex++) {
				try {
					dataTypes[dataTypeIndex] = DataTypeName.getDataTypeOf(dataTypeNames[dataTypeIndex]);
				} catch (VnanoException e) {
					e.setFileName(sourceFileName);
					e.setLineNumber(sourceLineNumber);
					throw e;
				}
			}


			int operandLength = wordLength - 2; // wordLength - opcode:1 - dataType:1
			Memory.Partition[] operandAddressTypes = new Memory.Partition[ operandLength ];
			int operandAddresses[] = new int[operandLength];


			for (int operandIndex=0; operandIndex<operandLength; operandIndex++) {

				// Data operands begin with the 2nd word.
				int wordIndex = operandIndex + 2;
				String word = words[wordIndex].trim();

				// The head character represents the kind of operand (register, variable identifier, immediate value, ...).
				char prefix = word.charAt(0);

				if (prefix == AssemblyWord.IMMEDIATE_OPERAND_PREFIX) {
						if (vmObjectCode.containsConstantData(word)) {
							operandAddresses[operandIndex] = vmObjectCode.getConstantDataAddress(word);
						} else {

							// String-type immediate value: recover the content of the string literal from the numberized literal.
							if (this.getDataTypeOfImmediateValueLiteral(word) == DataType.STRING) {
								String literalValue = this.getValuePartOfImmediateValueLiteral(word);
								int stringLiteralIndex = LiteralSyntax.getIndexOfNumberedStringLiteral(literalValue);
								literalValue = stringLiteralExtractResult[stringLiteralIndex];
								literalValue = LiteralSyntax.decodeEscapeSequences(literalValue);
								word = this.replaceImmediateValue(word, literalValue);
							}

							operandAddresses[operandIndex] = constantAddress;
							DataContainer<?> dataContainer = this.parseImmediateValue(word);
							vmObjectCode.addConstantData(word, dataContainer, constantAddress);
							constantAddress++;
						}
						operandAddressTypes[operandIndex] = Memory.Partition.CONSTANT;

				} else if (prefix == AssemblyWord.REGISTER_OPERAND_PREFIX) {

						String addressWord = word.substring(1, word.length());
						int registerAddress = Integer.parseInt(addressWord);
						operandAddresses[operandIndex] = registerAddress;
						if (!vmObjectCode.containsRegister(registerAddress)) {
							vmObjectCode.addRegister(registerAddress);
						}
						operandAddressTypes[operandIndex] = Memory.Partition.REGISTER;
						if (registerMaxAddress < operandAddresses[operandIndex]) {
							registerMaxAddress = operandAddresses[operandIndex];
						}

				} else if (prefix == AssemblyWord.IDENTIFIER_OPERAND_PREFIX) {

						// Convert the local variable identifier to the memory address of the LOCAL partition.
						if (vmObjectCode.containsLocalVariable(word)) {

							operandAddresses[operandIndex] = vmObjectCode.getLocalVariableAddress(word);
							operandAddressTypes[operandIndex] = Memory.Partition.LOCAL;

						// Convert the global variable identifier to the memory address of the GLOBAL partition.
						} else if (vmObjectCode.containsGlobalVariable(word)) {

							operandAddresses[operandIndex] = vmObjectCode.getGlobalVariableAddress(word);
							operandAddressTypes[operandIndex] = Memory.Partition.GLOBAL;

						// Convert the function identifier to the memory address of the CONSTANT partition,
						// in which function address is stored.
						} else if (vmObjectCode.containsFunction(word)) {

							int functionAddress = vmObjectCode.getFunctionAddress(word);

							String functionAddressImmediateValue
									= Character.toString(AssemblyWord.IMMEDIATE_OPERAND_PREFIX)
									+ DataTypeName.getDataTypeNameOf(DataType.INT64)
									+ AssemblyWord.VALUE_SEPARATOR
									+ Integer.toString(functionAddress);

							operandAddressTypes[operandIndex] = Memory.Partition.CONSTANT;
							operandAddresses[operandIndex] = constantAddress;
							DataContainer<?> dataContainer = this.parseImmediateValue(functionAddressImmediateValue);
							vmObjectCode.addConstantData(functionAddressImmediateValue, dataContainer, constantAddress);
							constantAddress++;

						} else {
							throw new VnanoFatalException("Undefined identifier has detected in operands: " + word);
						}

				} else if (prefix == AssemblyWord.LABEL_OPERAND_PREFIX) {

						int labelAddress = vmObjectCode.getLabelAddress(word);

						String functionAddressImmediateValue
								= Character.toString(AssemblyWord.IMMEDIATE_OPERAND_PREFIX)
								+ DataTypeName.getDataTypeNameOf(DataType.INT64)
								+ AssemblyWord.VALUE_SEPARATOR
								+ Integer.toString(labelAddress);

						operandAddressTypes[operandIndex] = Memory.Partition.CONSTANT;
						operandAddresses[operandIndex] = constantAddress;
						DataContainer<?> dataContainer = this.parseImmediateValue(functionAddressImmediateValue);
						vmObjectCode.addConstantData(functionAddressImmediateValue, dataContainer, constantAddress);
						constantAddress++;

				} else if (prefix == AssemblyWord.PLACEHOLDER_OPERAND_PREFIX) {
						operandAddresses[operandIndex] = 0;
						operandAddressTypes[operandIndex] = Memory.Partition.NONE;
				}
			}

			vmObjectCode.addInstruction(
				new Instruction(
					operationCode, dataTypes, operandAddressTypes, operandAddresses,
					Memory.Partition.CONSTANT, metaAddress
				)
			);
		}

		return vmObjectCode;
	}


	/**
	 * Append LABEL instructions at locations of labels and CALL instructions in the specified code.
	 * 
	 * As same as a NOP instructions, a LABEL instruction does nothing when it is executed, 
	 * but it makes optimization easy, by making it explicit that processing flow may jumps to there.
	 *
	 * @param assemblyCode The VRIL assembly code.
	 * @return The VRIL assembly code to which LABEL instructions have been appended.
	 */
	private String appendLabelInstructions(String assemblyCode) {

		StringBuilder codeBuilder = new StringBuilder();

		String[] lines = assemblyCode.split(AssemblyWord.INSTRUCTION_SEPARATOR_REGEX);
		int lineLength = lines.length;

		for (int lineIndex=0; lineIndex<lineLength; lineIndex++) {

			String line = lines[lineIndex];
			codeBuilder.append(line);
			codeBuilder.append(AssemblyWord.INSTRUCTION_SEPARATOR);

			line = line.trim();
			String labelCode
				= AssemblyWord.LINE_SEPARATOR
				+ AssemblyWord.WORD_SEPARATOR
				+ OperationCode.LABEL.name()
				+ AssemblyWord.WORD_SEPARATOR
				+ DataTypeName.VOID
				+ AssemblyWord.WORD_SEPARATOR
				+ AssemblyWord.PLACEHOLDER_OPERAND_PREFIX
				+ AssemblyWord.INSTRUCTION_SEPARATOR
				;

			// An empty line:
			if (line.length() == 0) {
				continue;
			}

			// Put a LABEL instruction at the label directive.
			if (line.startsWith(AssemblyWord.LABEL_DIRECTIVE)) {
				codeBuilder.append(labelCode);
				continue;
			}

			String[] words = line.split(AssemblyWord.WORD_SEPARATOR_REGEX);
			String operationCode = words[0];

			// Put a LABEL instruction just after a CALL instruction, 
			// because processing flow jumps to there when it when it has returned from the callee function.
			if (operationCode.equals(OperationCode.CALL.name())) {
				codeBuilder.append(labelCode);
			}
		}
		return codeBuilder.toString();
	}


	/**
	 * Parses an immediate value literal, and create a data container storing the data of the immediate value.
	 *
	 * @param immediateValue The immedaite value literal.
	 * @return The data container storing the data of the immediate value.
	 * @throws VnanoException Thrown when invalid immediate value literal has been detected.
	 */
	private DataContainer<?> parseImmediateValue(String immediateValue) throws VnanoException {

		int separatorIndex = immediateValue.indexOf(AssemblyWord.VALUE_SEPARATOR);
		String dataTypeName = immediateValue.substring(1, separatorIndex);
		String valueText = immediateValue.substring(separatorIndex+1, immediateValue.length());
		DataType dataType = DataTypeName.getDataTypeOf(dataTypeName);

		switch (dataType) {
			case INT64 : {
				DataContainer<long[]> data = new DataContainer<long[]>();
				try {
					// Hex literal:
					if (valueText.startsWith(LiteralSyntax.INT_LITERAL_HEX_PREFIX)) {
						valueText = valueText.substring(LiteralSyntax.INT_LITERAL_HEX_PREFIX.length());
						data.setInt64ScalarData(Long.parseLong(valueText, 16));

					// Octal literal:
					} else if (valueText.startsWith(LiteralSyntax.INT_LITERAL_OCT_PREFIX)) {
						valueText = valueText.substring(LiteralSyntax.INT_LITERAL_OCT_PREFIX.length());
						data.setInt64ScalarData(Long.parseLong(valueText, 8));

					// Binary literal:
					} else if (valueText.startsWith(LiteralSyntax.INT_LITERAL_BIN_PREFIX)) {
						valueText = valueText.substring(LiteralSyntax.INT_LITERAL_BIN_PREFIX.length());
						data.setInt64ScalarData(Long.parseLong(valueText, 2));

					// Decimal literal:
					} else {
						data.setInt64ScalarData(Long.parseLong(valueText));
					}
				} catch(NumberFormatException e) {
					VnanoException vse = new VnanoException(ErrorType.INVALID_IMMEDIATE_VALUE, new String[] { valueText});
					throw vse;
				}
				return data;
			}
			case FLOAT64 : {
				DataContainer<double[]> data = new DataContainer<double[]>();
				try {
					data.setFloat64ScalarData(Double.parseDouble(valueText));
				} catch(NumberFormatException e) {
					VnanoException vse = new VnanoException(ErrorType.INVALID_IMMEDIATE_VALUE, new String[] { valueText});
					throw vse;
				}
				return data;
			}
			case BOOL : {
				DataContainer<boolean[]> data = new DataContainer<boolean[]>();
				if (valueText.equals(LiteralSyntax.TRUE)) {
					data.setBoolScalarData(true);
				} else if (valueText.equals(LiteralSyntax.FALSE)) {
					data.setBoolScalarData(false);
				} else {
					VnanoException vse = new VnanoException(ErrorType.INVALID_IMMEDIATE_VALUE, new String[] { valueText});
					throw vse;
				}
				return data;
			}
			case STRING : {
				DataContainer<String[]> data = new DataContainer<String[]>();
				valueText = valueText.substring(1, valueText.length()-1); // Remove double-quotations
				data.setStringScalarData(valueText);
				return data;
			}
			default: {
				throw new VnanoFatalException("Unknown literal data type: " + dataType);
			}
		}
	}


	/**
	 * Reads the data-type part of the specified intermediate value literal.
	 *
	 * @param immediateValueLiteral The intermediate value literal.
	 * @return The data-type of the intermediate value.
	 * @throws VnanoException Thrown when an invalid data-type is described in the literal.
	 */
	private DataType getDataTypeOfImmediateValueLiteral(String immediateValueLiteral) throws VnanoException {
		int separatorIndex = immediateValueLiteral.indexOf(AssemblyWord.VALUE_SEPARATOR);
		String dataTypeName = immediateValueLiteral.substring(1, separatorIndex);
		DataType dataType = DataTypeName.getDataTypeOf(dataTypeName);
		return dataType;
	}

	/**
	 * Reads the value part of the specified intermediate value literal.
	 *
	 * @param immediateValueLiteral The intermediate value literal.
	 * @return The value part of the literal.
	 */
	private String getValuePartOfImmediateValueLiteral(String immediateValueLiteral) {
		int separatorIndex = immediateValueLiteral.indexOf(AssemblyWord.VALUE_SEPARATOR);
		String valuePart = immediateValueLiteral.substring(separatorIndex+1, immediateValueLiteral.length());
		return valuePart;
	}

	/**
	 * Replaces the value part of the specified intermediate value literal to the specified value.
	 *
	 * @param immediateValueLiteral The intermediate value literal.
	 * @param newValue The value to replace the value part of the literal.
	 * @return The intermediate value literal in which the value part has been replaced.
	 */
	private String replaceImmediateValue(String immediateValueLiteral, String newValue) {
		int separatorIndex = immediateValueLiteral.indexOf(AssemblyWord.VALUE_SEPARATOR);
		String frontPart = immediateValueLiteral.substring(0, separatorIndex);
		String newLiteral = frontPart + AssemblyWord.VALUE_SEPARATOR + newValue;
		return newLiteral;
	}


	/**
	 * Processes some directives
	 * (declarations of local/global variables, functions, labels) in the specified VRIL assembly code, 
	 * and returns an VM object code having information of declared variables/functions/labels.
	 * 
	 * Note that, the returned VM object code is incomplete, 
	 *  so it is necessary to append information (instructions and so on) in the latter steps.
	 *
	 * @param assemblyCode The VRIL assembly code.
	 * @return The VM object code having information of variables/functions/labels, declared by directives in the VRIL assembly code.
	 */
	private VirtualMachineObjectCode preprocessDirectives(String assemblyCode, VariableTable globalVariableTable, FunctionTable functionTable) {

		VirtualMachineObjectCode vmObjectCode = new VirtualMachineObjectCode();

		int localAddress = 0;

		String[] lines = assemblyCode.split(AssemblyWord.INSTRUCTION_SEPARATOR_REGEX);
		int lineLength = lines.length;

		int instructionIndex = 0;

		for (int lineIndex=0; lineIndex<lineLength; lineIndex++) {

			String line = lines[lineIndex].trim();
			if (line.length() == 0) {
				continue;
			}
			String[] words = line.split(AssemblyWord.WORD_SEPARATOR_REGEX);

			// Local variable directive:
			if (line.startsWith(AssemblyWord.LOCAL_VARIABLE_DIRECTIVE)) {
				String identifier = words[1];
				vmObjectCode.addLocalVariable(identifier, localAddress);
				localAddress++;
			}

			// Global variable directive:
			if (line.startsWith(AssemblyWord.GLOBAL_VARIABLE_DIRECTIVE)) {
				String identifier = words[1];
				AbstractVariable variable = globalVariableTable.getVariableByAssemblyIdentifier(identifier);
				int globalAddress = globalVariableTable.getIndexOf(variable);
				vmObjectCode.addGlobalVariable(identifier, globalAddress);
			}

			// Function directive:
			if (line.startsWith(AssemblyWord.GLOBAL_FUNCTION_DIRECTIVE)) {
				String identifier = words[1];
				String signature = identifier.substring(1, identifier.length()); // Remove the first char because it is a prefix.
				AbstractFunction function = functionTable.getFunctionBySignature(signature);
				int functionAddress = functionTable.getIndexOf(function);
				vmObjectCode.addFunction(identifier, functionAddress);
			}

			// Label directive:
			if (line.startsWith(AssemblyWord.LABEL_DIRECTIVE)) {
				String identifier = words[1];
				vmObjectCode.addLabel(identifier, instructionIndex);
			}

			if (!line.startsWith(Character.toString(AssemblyWord.DIRECTIVE_PREFIX))) {
				instructionIndex++;
			}
		}
		return vmObjectCode;
	}

}
