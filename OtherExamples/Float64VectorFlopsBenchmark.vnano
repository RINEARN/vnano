/*
 * A benchmarking program for measuring the peak performance of 
 * 64-bit floating-point vector operations of Vnano Engine.
 * Vnano処理系の倍精度浮動小数点ベクトル演算ピーク性能計測用ベンチマークプログラム
 * --------------------------------------------------------------------------------
 * This file is released under CC0.
 * Written in 2018-2019 by RINEARN (Fumihiro Matsui)
 * --------------------------------------------------------------------------------
 * 
 * Preparing - 事前準備
 * 
 *     Execute "build.bat" or "build.sh" in advance to generate "Vnano.jar".
 *     あらかじめ build.bat か build.sh を実行し、Vnano.jar を生成しておいて下さい。
 * 
 * 
 * How to run this code - このコードの実行方法 :
 * 
 *     Set the current directory to the location of "Vnano.jar" by cd command, then:
 *     VCSSL.jar と同じ場所に cd コマンドで移動し、以下のように実行します：
 * 
 *         java -jar Vnano.jar OtherExamples/Float64VectorFlopsBenchmark.vnano --encoding UTF-8 --accelerator true
 * 
 * Expected result - 正常な実行結果 :
 * 
 *     OPERATING_SPEED = 4.8389764430687805 [GFLOPS]
 *     REQUIRED_TIME = 42.323 [SEC]
 *     TOTAL_OPERATIONS = 204800000000 [xFLOAT64_ADD]
 *     VECTOR_SIZE = 2048 [x64BIT]
 *     OPERATED_VALUES = { 1.0E8, 2.0E8, 3.0E8, ... , 2.047E11, 2.048E11 }
 * 
 *     * Values of OPERATING_SPEED and REQUIRED_TIME are dependent on your environment.
 *     ※OPERATING_SPEED と REQUIRED_TIME の値は環境に依存します。
 * 
 * --------------------------------------------------------------------------------
 */

int VECTOR_SIZE = 2048;
int LOOP_N = 1000*1000;
int FLOP_PER_LOOP = VECTOR_SIZE * 100;
int TOTAL_FLOP = FLOP_PER_LOOP * LOOP_N;

double x[VECTOR_SIZE];
double y[VECTOR_SIZE];
for (int i=0; i<VECTOR_SIZE; i++) {
	x[i] = 0.0;
	y[i] = i + 1.0;
}

int beginTime = time();

for (int i=0; i<LOOP_N; ++i) {

	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;
	x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y; x+=y;

}

int endTime = time();
double requiredTime = (endTime - beginTime) / 1000.0;
double flops = TOTAL_FLOP / requiredTime;

output("OPERATING_SPEED = " +  flops/(1000.0*1000.0*1000.0) + " [GFLOPS]\n");
output("REQUIRED_TIME = "+ requiredTime + " [SEC]\n");
output("TOTAL_OPERATIONS = " + TOTAL_FLOP + " [xFLOAT64_ADD]\n");
output("VECTOR_SIZE = " + VECTOR_SIZE + " [x64BIT]\n");
output("OPERATED_VALUES = { ");
output(x[0] + ", " + x[1] + ", " + x[2] + ", ... " + x[VECTOR_SIZE-2] + ", " + x[VECTOR_SIZE-1]);
output(" }\n");

